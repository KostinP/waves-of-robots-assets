Обработка директории: ./Resources/Localization
==========================================

Файл: ./Resources/Localization/ru.json
﻿{
    "game_title": "waves of ROBOTS",
    "single_player": "Одиночная игра",
    "create_lobby": "Начать игру",
    "browse_lobbies": "Поиск лобби",
    "statistics": "Статистика",
    "quit": "Выход",
    "lobby_name": "Название лобби",
    "max_players": "Макс. игроков",
    "create": "Создать",
    "refresh_lobby_list": "Обновить",
    "back": "Назад",
    "available_lobbies": "Доступные лобби",
    "start_game": "Начать игру",
    "leave_lobby": "Покинуть лобби",
    "lobby": "Лобби: ---",
    "players": "Игроки: 0/0",
    "network_game": "СЕТЕВАЯ ИГРА",
    "join_lobby": "Присоединиться",
    "player_count": "Количество игроков",
    "type": "Тип",
    "lobby_type": "Тип лобби",
    "enter_name": "Введите название",
    "open": "Открытое",
    "closed": "Закрытое",
    "enter_password": "Введите пароль",
    "difficulty": "Сложность",
    "robot_vacuum": "Робот-пылесос",
    "combat_toaster": "Боевой тостер",
    "gpt_coffee": "ChatGPT на кофеине",
    "wave_count": "Количество волн",
    "bot_count": "Количество ботов",
    "infinity": "Бесконечность",
    "close": "Закрыть",
    "settings": "Настройки",
    "players_header": "Игроки",
    "player_name": "Игроки",
    "weapon": "Оружие",
    "ping": "Пинг",
    "kick": "Выгнать",
    "lobby_settings": "Настройки лобби",
    "disband_lobby": "Распустить лобби",
    "card_title": "Выберите 1 карту",
    "card_subtitle": "Один выбор – бесконечные последствия",
    "upgrade": "Улучшение",
    "current_player_name": "Имя игрока",
    "random": "Случайное",
    "default_arm": "Оружие по умолчанию",
    "common_gun1": "Огнемёт \"Термит\"",
    "common_gun2": "Автопушка \"Титан\"",
    "common_gun3": "Электрошокер \"Вольт\"",
    "common_gun4": "Двойной пулемёт \"Вихрь\"",
    "rare_gun1": "Лазерный дрон \"Фантом\"",
    "rare_gun2": "Ракетный отсек \"Гидра\"",
    "rare_gun3": "Ледяной луч \"Крио\"",
    "legendary_gun1": "Плазменный веер \"Аркан\"",
    "legendary_gun2": "Гравитационная пушка \"Небула\"",
    "music_volume": "Громкость музыки",
    "sound_volume": "Громкость звуков",
    "default_difficulty": "Сложность по умолчанию",
    "screen_resolution": "Разрешение экрана",
    "screen_quality": "Качество изображения",
    "language": "Язык интерфейса",
    "save_button": "Сохранить",
    "cancel_button": "Отменить",
    "lobby_name_label": "Название лобби",
    "player_count_label": "Количество игроков",
    "type_label": "Тип",
    "lobby_type_label": "Тип лобби",
    "players_header_label": "Игроки",
    "player_name_label": "Игрок",
    "weapon_label": "Оружие",
    "ping_label": "Пинг",
    "difficulty_label": "Сложность",
    "wave_count_label": "Количество волн",
    "lobby_settings_label": "Настройки лобби",
    "leave_game": "Покинуть игру"
}
Файл: ./Resources/Localization/en.json
﻿{
    "game_title": "waves of ROBOTS",
    "single_player": "Single Player",
    "create_lobby": "Start Game",
    "browse_lobbies": "Browse Lobbies",
    "statistics": "Statistics",
    "quit": "Quit",
    "lobby_name": "Lobby name",
    "max_players": "Max players",
    "create": "Create",
    "refresh_lobby_list": "Refresh",
    "back": "Back",
    "available_lobbies": "Available lobbies",
    "start_game": "Start Game",
    "leave_lobby": "Leave Lobby",
    "lobby": "Lobby: ---",
    "players": "Players: 0/0",
    "network_game": "NETWORK GAME",
    "join_lobby": "Join",
    "player_count": "Player count",
    "type": "Type",
    "lobby_type": "Lobby type",
    "enter_name": "Enter name",
    "open": "Open",
    "closed": "Closed",
    "enter_password": "Enter password",
    "difficulty": "Difficulty",
    "robot_vacuum": "Robot Vacuum",
    "combat_toaster": "Combat Toaster",
    "gpt_coffee": "ChatGPT on Caffeine",
    "wave_count": "Wave count",
    "bot_count": "Bot count",
    "infinity": "Infinity",
    "close": "Close",
    "settings": "Settings",
    "players_header": "Players",
    "player_name": "Players",
    "weapon": "Weapon",
    "ping": "Ping",
    "kick": "Kick",
    "lobby_settings": "Lobby Settings",
    "disband_lobby": "Disband Lobby",
    "card_title": "Select 1 card",
    "card_subtitle": "One choice — endless consequences",
    "upgrade": "Upgrade",
    "current_player_name": "Player name",
    "random": "Random",
    "default_arm": "Default arm",
    "common_gun1": "Termit Flamethrower",
    "common_gun2": "Titan Autocannon",
    "common_gun3": "Volt Stun Gun",
    "common_gun4": "Vikhr Twin Machine Gun",
    "rare_gun1": "Phantom Laser Drone",
    "rare_gun2": "Hydra Missile Pod",
    "rare_gun3": "Krio Ice Ray",
    "legendary_gun1": "Arcane Plasma Caster",
    "legendary_gun2": "Nebula Gravity Gun",
    "music_volume": "Music volume",
    "sound_volume": "Sound volume",
    "default_difficulty": "Default difficulty",
    "screen_resolution": "Screen resolution",
    "screen_quality": "Screen quality",
    "language": "Language",
    "save_button": "Save",
    "cancel_button": "Cancel",
    "lobby_name_label": "Lobby name",
    "player_count_label": "Player count",
    "type_label": "Type",
    "lobby_type_label": "Lobby type",
    "players_header_label": "Players",
    "player_name_label": "Player",
    "weapon_label": "Weapon",
    "ping_label": "Ping",
    "difficulty_label": "Difficulty",
    "wave_count_label": "Wave count",
    "lobby_settings_label": "Lobby Settings",
    "leave_game": "Leave game"
}
Обработка директории: ./Scripts
==========================================

Файл: ./Scripts/PlayerFeature/UI/PauseMenuController.cs
﻿using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.InputSystem;

public class PauseMenuController : MonoBehaviour
{
    private VisualElement _root;
    private bool _paused = false;

    void Start()
    {
        _root = GetComponent<UIDocument>().rootVisualElement;
        _root.style.display = DisplayStyle.None;

        _root.Q<Button>("btnResume").clicked += Resume;
        _root.Q<Button>("btnLeaveGame").clicked += LeaveGame;
    }

    void Update()
    {
        if (Keyboard.current.escapeKey.wasPressedThisFrame)
            TogglePause();
    }

    void TogglePause()
    {
        _paused = !_paused;
        _root.style.display = _paused ? DisplayStyle.Flex : DisplayStyle.None;
        Time.timeScale = _paused ? 0f : 1f;
        AudioListener.pause = _paused;
    }

    void Resume() => TogglePause();

    void LeaveGame()
    {
        TogglePause();
        UIManager.Instance.LeaveGame();
    }
}
Файл: ./Scripts/PlayerFeature/UI/SceneUIController.cs
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneUIController : MonoBehaviour
{
    void Start()
    {
        SceneManager.LoadSceneAsync("HUDScene", LoadSceneMode.Additive);
        SceneManager.LoadSceneAsync("PauseMenuScene", LoadSceneMode.Additive);
        SceneManager.sceneLoaded += OnSceneLoaded;
    }

    void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        if (scene.name == "HUDScene")
        {
            var hudRoot = GameObject.Find("HUDRoot")?.GetComponent<HUDController>();
            UIManager.Instance.SetHUDController(hudRoot);
        }
        else if (scene.name == "PauseMenuScene")
        {
            var pauseRoot = GameObject.Find("PauseMenuRoot")?.GetComponent<PauseMenuController>();
            UIManager.Instance.SetPauseController(pauseRoot);
        }
    }

    void OnDestroy()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
        var hudScene = SceneManager.GetSceneByName("HUDScene");
        if (hudScene.isLoaded) SceneManager.UnloadSceneAsync("HUDScene");

        var pauseScene = SceneManager.GetSceneByName("PauseMenuScene");
        if (pauseScene.isLoaded) SceneManager.UnloadSceneAsync("PauseMenuScene");
    }
}
Файл: ./Scripts/PlayerFeature/UI/HUDController.cs
﻿using UnityEngine;
using UnityEngine.UIElements;
using Unity.Entities;
using Unity.Collections;
using Unity.NetCode;
using System.Linq;

public class HUDController : MonoBehaviour
{
    private VisualElement _hudRoot;
    private VisualElement _playersContainer;

    void Start()
    {
        _hudRoot = GetComponent<UIDocument>().rootVisualElement;
        _playersContainer = _hudRoot.Q<VisualElement>("hud__players");
        InvokeRepeating(nameof(UpdatePlayerList), 0f, 1f);
    }

    public void UpdatePlayerList()
    {
        _playersContainer.Clear();
        var clientWorld = World.All.FirstOrDefault(w => w.IsClient());
        if (clientWorld == null) return;

        var em = clientWorld.EntityManager;
        var query = em.CreateEntityQuery(ComponentType.ReadOnly<PlayerComponent>());
        var players = query.ToComponentDataArray<PlayerComponent>(Allocator.Temp);

        for (int i = 0; i < players.Length; i++)
        {
            var p = players[i];
            string name = p.Name.ToString();
            string ping = p.Ping.ToString() + "мс";
            CreatePlayerHUD(_playersContainer, name, ping);
        }
        players.Dispose();
    }

    private void CreatePlayerHUD(VisualElement container, string name, string ping)
    {
        var player = new VisualElement { pickingMode = PickingMode.Ignore };
        player.AddToClassList("hud__player");
        var icon = new VisualElement { pickingMode = PickingMode.Ignore };
        icon.AddToClassList("hud__player-icon");
        icon.AddToClassList("mic");
        var nameLabel = new Label(name) { pickingMode = PickingMode.Ignore };
        nameLabel.AddToClassList("hud__player-name");
        var pingLabel = new Label(ping) { pickingMode = PickingMode.Ignore };
        pingLabel.AddToClassList("hud__player-ping");
        float pingValue = float.Parse(ping.Replace("мс", ""));
        if (pingValue < 50) pingLabel.AddToClassList("good");
        else if (pingValue < 150) pingLabel.AddToClassList("medium");
        else pingLabel.AddToClassList("bad");
        player.Add(icon); player.Add(nameLabel); player.Add(pingLabel);
        container.Add(player);
    }
}
Файл: ./Scripts/PlayerFeature/Network/SpawnSystem.cs
﻿using Unity.Entities;
using Unity.NetCode;
using Unity.Mathematics;
using Unity.Transforms;
using Unity.Collections;

[WorldSystemFilter(WorldSystemFilterFlags.ServerSimulation)]
[UpdateInGroup(typeof(SimulationSystemGroup))]
public partial struct SpawnSystem : ISystem
{
    public void OnCreate(ref SystemState state)
    {
        state.RequireForUpdate<NetworkId>();
    }

    public void OnUpdate(ref SystemState state)
    {
        var ecb = new EntityCommandBuffer(Allocator.Temp);

        var prefabEntity = SystemAPI.QueryBuilder()
            .WithAll<PlayerPrefabComponent>()
            .Build()
            .TryGetSingleton(out PlayerPrefabComponent prefabData)
            ? prefabData.Prefab
            : Entity.Null;

        foreach (var (spawnCmd, entity) in SystemAPI.Query<RefRO<SpawnPlayerCommand>>().WithEntityAccess())
        {
            if (prefabEntity == Entity.Null)
                continue;

            var playerEntity = ecb.Instantiate(prefabEntity);
            ecb.SetComponent(playerEntity, LocalTransform.FromPosition(float3.zero));
            ecb.AddComponent(playerEntity, new PlayerComponent
            {
                Name = new FixedString128Bytes("Player"),
                ConnectionId = spawnCmd.ValueRO.ConnectionId,
                Ping = 0
            });
            ecb.AddComponent(playerEntity, new GhostOwner());
            ecb.DestroyEntity(entity);
        }

        ecb.Playback(state.EntityManager);
    }
}

Файл: ./Scripts/PlayerFeature/Movement/InputSystem.cs
﻿// Assets/Scripts/InputSystem.cs
using Unity.Entities;
using UnityEngine.InputSystem;
using Unity.Mathematics;

[WorldSystemFilter(WorldSystemFilterFlags.ClientSimulation)]
[UpdateInGroup(typeof(InitializationSystemGroup))]
public partial struct InputSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        if (Mouse.current.leftButton.wasPressedThisFrame)
        {
            var mousePos = Mouse.current.position.ReadValue();
            foreach (var input in SystemAPI.Query<RefRW<PlayerInputComponent>>())
            {
                input.ValueRW.IsClicked = true;
                input.ValueRW.MouseClickPosition = new float2(mousePos.x, mousePos.y);
            }
        }
    }
}
Файл: ./Scripts/PlayerFeature/Movement/NavMeshMovementSystem.cs
﻿// Assets/Scripts/NavMeshMovementSystem.cs
using Unity.Entities;
using Unity.NetCode;
using Unity.Mathematics;
using Unity.Transforms;
using UnityEngine.AI;
using UnityEngine; // Для Camera и Physics

[WorldSystemFilter(WorldSystemFilterFlags.ClientSimulation)]
[UpdateInGroup(typeof(SimulationSystemGroup))]
public partial struct NavMeshMovementSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        foreach (var (transform, input) in SystemAPI.Query<RefRW<LocalTransform>, RefRO<PlayerInputComponent>>())
        {
            if (input.ValueRO.IsClicked)
            {
                var ray = Camera.main.ScreenPointToRay(new Vector3(input.ValueRO.MouseClickPosition.x, input.ValueRO.MouseClickPosition.y, 0));
                if (Physics.Raycast(ray, out var hit))
                {
                    var path = new NavMeshPath();
                    NavMesh.CalculatePath(transform.ValueRO.Position, hit.point, NavMesh.AllAreas, path);
                    // Implement path following in a component, here simplified lerp
                    transform.ValueRW.Position = math.lerp(transform.ValueRO.Position, hit.point, 0.1f);
                }
            }
        }
    }
}
Файл: ./Scripts/PlayerFeature/Movement/PlayerMovementSystem.cs
﻿using Unity.Entities;
using Unity.NetCode;
using Unity.Mathematics;
using Unity.Transforms;
using Unity.Collections;

[WorldSystemFilter(WorldSystemFilterFlags.ClientSimulation | WorldSystemFilterFlags.ServerSimulation)]
public partial struct PlayerMovementSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        foreach (var (transform, input) in SystemAPI.Query<RefRW<LocalTransform>, RefRO<PlayerInputComponent>>())
        {
            if (input.ValueRO.IsClicked)
            {
                // movement placeholder
                transform.ValueRW.Position += new float3(0, 0, 1) * SystemAPI.Time.DeltaTime;
            }
        }
    }
}

Файл: ./Scripts/PlayerFeature/Visual/PlayerPrefabBaker.cs
﻿using Unity.Entities;
using UnityEngine;
using Unity.Transforms;

public class PlayerPrefabAuthoring : MonoBehaviour { }

public class PlayerPrefabBaker : Baker<PlayerPrefabAuthoring>
{
    public override void Bake(PlayerPrefabAuthoring authoring)
    {
        // Создаём сущность-префаб игрока
        var prefabEntity = CreateAdditionalEntity(TransformUsageFlags.None);

        // Копируем все компоненты с игрока
        AddComponent(prefabEntity, LocalTransform.FromPosition(Vector3.zero));
        AddComponent(prefabEntity, new PlayerComponent
        {
            Name = new Unity.Collections.FixedString128Bytes("Player"),
            ConnectionId = 0,
            Ping = 0
        });

        // Сохраняем префаб в singleton
        var holderEntity = GetEntity(TransformUsageFlags.None);
        AddComponent(holderEntity, new PlayerPrefabComponent { Prefab = prefabEntity });
    }
}
Файл: ./Scripts/PlayerFeature/Visual/PlayerAuthoring.cs
﻿using UnityEngine;
using Unity.Entities;
using Unity.NetCode;
using Unity.Transforms;

public class PlayerAuthoring : MonoBehaviour
{
    // Поставь этот скрипт на prefab игрока
}

public class PlayerBaker : Baker<PlayerAuthoring>
{
    public override void Bake(PlayerAuthoring authoring)
    {
        var entity = GetEntity(TransformUsageFlags.Dynamic);

        // Добавляем компоненты ИГРОКА
        AddComponent(entity, LocalTransform.FromPosition(Vector3.zero));
        AddComponent(entity, new PlayerComponent
        {
            Name = new Unity.Collections.FixedString128Bytes("Player"),
            ConnectionId = 0,
            Ping = 0
        });

        // ❌ НЕ ДОБАВЛЯЙ PlayerPrefabComponent на игрока!
        // AddComponent<PlayerPrefabComponent>(entity); // УДАЛИ ЭТУ СТРОКУ
    }
}

Файл: ./Scripts/PlayerFeature/Data/ECSGameData.cs
﻿// Assets/Scripts/ECSComponents.cs
using Unity.Entities;
using Unity.NetCode;
using Unity.Mathematics;
using Unity.Collections;
using Unity.Networking.Transport;
using System;

[GhostComponent(PrefabType = GhostPrefabType.AllPredicted)]
public struct PlayerInputComponent : IInputComponentData
{
    public bool IsClicked;
    public float2 MouseClickPosition;
}

public struct StartGameCommand : IComponentData
{
}

public struct SpawnPlayerCommand : IComponentData
{
    public ulong ConnectionId;
}

public struct PlayerPrefabComponent : IComponentData
{
    public Entity Prefab;
}
Файл: ./Scripts/Core/UI/UIManager.cs
using UnityEngine;
using UnityEngine.SceneManagement;
using Unity.NetCode;
using UnityEngine.InputSystem;
using System;
using System.Collections;

public class UIManager : MonoBehaviour
{
    public static UIManager Instance { get; private set; }

    [SerializeField] private InputActionAsset inputActions;
    public InputActionAsset InputActions => inputActions;

    public LobbyManager LobbyManager { get; private set; }

    private MainMenuController _mainMenuController;
    private HUDController _hudController;
    private PauseMenuController _pauseController;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            LobbyManager = GetComponent<LobbyManager>() ?? gameObject.AddComponent<LobbyManager>();
            SceneManager.sceneLoaded += OnSceneLoaded;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        if (scene.name == "MainMenuScene")
        {
            _mainMenuController = FindObjectOfType<MainMenuController>();
        }
        else if (scene.name == "GameCoreScene")
        {
            // HUD и Pause загружаются в SceneUIController
        }
    }

    public void SetHUDController(HUDController controller) => _hudController = controller;
    public void SetPauseController(PauseMenuController controller) => _pauseController = controller;

    public void OnPlayerJoined(int connectionId, string name)
    {
        OnPlayersUpdated();
    }

    public void OnPlayerLeft(int connectionId)
    {
        OnPlayersUpdated();
    }

    public void OnPlayersUpdated()
    {
        _mainMenuController?.UpdatePlayerList();
        _hudController?.UpdatePlayerList();
    }

    public void OnLobbyListUpdated()
    {
        _mainMenuController?.OnLobbyListUpdated();
    }

    public void OnLobbyCreated()
    {
        _mainMenuController?.OnLobbyCreated();
    }

    public void OnJoinedAsClient()
    {
        _mainMenuController?.OnJoinedAsClient();
    }

    public void StartGame()
    {
        LobbyManager.StartGame();
        SceneManager.LoadScene("GameCoreScene");
    }

    public void LeaveGame()
    {
        try
        {
            // Останавливаем все сетевые активности
            var lobbyManager = FindObjectOfType<LobbyManager>();
            if (lobbyManager != null)
            {
                // ФИКС: Используем DisbandLobby вместо прямого вызова
                lobbyManager.DisbandLobby();
            }
            else
            {
                Debug.LogWarning("LobbyManager not found, proceeding without disband");
                // Если менеджера нет, просто загружаем меню
                LoadMainMenuDirectly();
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Error leaving game: {e.Message}");
            LoadMainMenuDirectly();
        }
    }

    public string GetCurrentScreen()
    {
        var mainMenuController = FindObjectOfType<MainMenuController>();
        return mainMenuController?.GetCurrentScreen() ?? "unknown";
    }

    private void LoadMainMenuDirectly()
    {
        if (Application.CanStreamedLevelBeLoaded("MainMenu"))
        {
            SceneManager.LoadScene("MainMenu");
        }
        else
        {
            SceneManager.LoadScene(0);
        }
    }

    public void ShowMainMenuScreen()
    {
        _mainMenuController?.ShowScreen(UIScreenManager.MenuScreenName);
    }

    public void ShowLobbyListScreen()
    {
        _mainMenuController?.ShowScreen(UIScreenManager.LobbyListScreenName);
        OnLobbyListUpdated();
    }

    public void ReturnToLobbyList()
    {
        Debug.Log("UIManager: Returning to lobby list");

        try
        {
            // Используем _mainMenuController
            if (_mainMenuController != null)
            {
                _mainMenuController.ReturnToLobbyList();
            }
            else
            {
                // Если контроллер не найден, пытаемся найти его
                _mainMenuController = FindObjectOfType<MainMenuController>();
                _mainMenuController?.ReturnToLobbyList();
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Error in ReturnToLobbyList: {e.Message}");
        }
    }

    private IEnumerator DelayedLobbyUpdate()
    {
        yield return new WaitForSeconds(0.5f);
        OnLobbyListUpdated();

        // Принудительный запрос discovery
        if (LobbyDiscovery.Instance != null)
        {
            LobbyDiscovery.Instance.ForceDiscovery();
        }
    }

    private void OnDestroy()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }
}
Файл: ./Scripts/Core/UI/LocalizationManager.cs
// Assets/Scripts/UI/LocalizationManager.cs
using UnityEngine;
using UnityEngine.UIElements;
using System.Collections.Generic;
using System;
using System.Collections;

public class LocalizationManager : MonoBehaviour
{
    public static LocalizationManager Instance { get; private set; }

    public event Action OnLanguageChanged;

    [SerializeField] private SystemLanguage _defaultLanguage = SystemLanguage.English;

    private Dictionary<string, string> _currentLocalization = new Dictionary<string, string>();
    private UIDocument _uiDocument;
    private SystemLanguage _currentLanguage;
    private VisualElement _rootVisualElement;

    // Кэш для всех UIDocument'ов в сцене
    private List<UIDocument> _allUiDocuments = new List<UIDocument>();

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);

            _uiDocument = GetComponent<UIDocument>();
            
            // Находим все UIDocument'ы в сцене
            RefreshUiDocuments();
            
            // Подписываемся на событие изменения настроек
            if (SettingsManager.Instance != null)
            {
                SettingsManager.Instance.OnSettingsChanged += OnSettingsChanged;
            }
            
            Debug.Log("LocalizationManager initialized");
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        // Получаем root visual element
        if (_uiDocument != null)
        {
            _rootVisualElement = _uiDocument.rootVisualElement;
        }

        // Загружаем язык из настроек или используем системный
        if (SettingsManager.IsReady())
        {
            LoadLanguage(SettingsManager.Instance.CurrentSettings.language, false);
        }
        else
        {
            DetectAndLoadLanguage();
        }
    }

    // Обновляем список всех UIDocument'ов
    private void RefreshUiDocuments()
    {
        _allUiDocuments.Clear();
        _allUiDocuments.AddRange(FindObjectsOfType<UIDocument>());
        Debug.Log($"Found {_allUiDocuments.Count} UI documents in scene");
    }

    private void OnSettingsChanged(GameSettings newSettings)
    {
        // При изменении настроек меняем язык
        if (newSettings.language != _currentLanguage)
        {
            LoadLanguage(newSettings.language, true);
        }
    }

    private void DetectAndLoadLanguage()
    {
        SystemLanguage systemLanguage = Application.systemLanguage;

        if (systemLanguage == SystemLanguage.Russian || systemLanguage == SystemLanguage.English)
        {
            LoadLanguage(systemLanguage, false);
        }
        else
        {
            LoadLanguage(_defaultLanguage, false);
        }
    }

    public void LoadLanguage(SystemLanguage language, bool forceUpdate = true)
    {
        Debug.Log($"Loading language: {language}, forceUpdate: {forceUpdate}");
        
        // Если язык не изменился, выходим
        if (_currentLanguage == language && !forceUpdate)
            return;

        _currentLanguage = language;
        string langCode = GetLanguageCode(language);
        var localizationFile = Resources.Load<TextAsset>($"Localization/{langCode}");

        if (localizationFile == null)
        {
            Debug.LogWarning($"Localization file for {language} not found, using default");
            localizationFile = Resources.Load<TextAsset>($"Localization/en");
        }

        if (localizationFile != null)
        {
            ParseLocalizationFile(localizationFile.text);
            
            // Всегда обновляем UI при смене языка
            UpdateAllUIElements();

            // Вызываем событие об изменении языка
            OnLanguageChanged?.Invoke();
            
            Debug.Log($"Language changed to: {language}, UI updated");
        }
        else
        {
            Debug.LogError("Default localization file not found!");
        }
    }

    public void SwitchLanguage()
    {
        var newLanguage = _currentLanguage == SystemLanguage.English ?
            SystemLanguage.Russian : SystemLanguage.English;
        LoadLanguage(newLanguage, true);
    }

    private string GetLanguageCode(SystemLanguage language)
    {
        return language == SystemLanguage.Russian ? "ru" : "en";
    }

    private void ParseLocalizationFile(string content)
    {
        _currentLocalization.Clear();

        try
        {
            var lines = content.Split('\n');
            foreach (var line in lines)
            {
                if (line.Trim().StartsWith("\"") && line.Contains(":"))
                {
                    var parts = line.Split(new[] { ':' }, 2);
                    if (parts.Length == 2)
                    {
                        var key = parts[0].Trim().Trim('"', ' ', '\t');
                        var value = parts[1].Trim().Trim('"', ',', ' ', '\t');
                        _currentLocalization[key] = value;
                    }
                }
            }
            Debug.Log($"Parsed {_currentLocalization.Count} localization entries");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error parsing localization file: {e.Message}");
        }
    }

    public string GetLocalizedText(string key)
    {
        if (_currentLocalization.ContainsKey(key))
            return _currentLocalization[key];
        
        Debug.LogWarning($"Localization key not found: {key}");
        return $"#{key}";
    }

    public void UpdateAllUIElements()
    {
        Debug.Log("Updating ALL UI elements with new language");
        
        // Обновляем все UIDocument'ы в сцене
        foreach (var uiDoc in _allUiDocuments)
        {
            if (uiDoc != null && uiDoc.rootVisualElement != null)
            {
                UpdateElementsWithPrefix(uiDoc.rootVisualElement, "#");
            }
        }
        
        Debug.Log($"Updated {_allUiDocuments.Count} UI documents");
    }

    private void UpdateElementsWithPrefix(VisualElement root, string prefix)
    {
        if (root == null) return;

        int updatedCount = 0;

        // ── LABELS ─────────────────────────────────────
        root.Query<Label>().ForEach(label =>
        {
            if (!string.IsNullOrEmpty(label.text) && label.text.StartsWith(prefix))
            {
                string key = label.text.Substring(prefix.Length);
                string localized = GetLocalizedText(key);
                if (label.text != localized)
                {
                    label.text = localized;
                    updatedCount++;
                }
            }
        });

        // ── BUTTONS ────────────────────────────────────
        root.Query<Button>().ForEach(button =>
        {
            if (!string.IsNullOrEmpty(button.text) && button.text.StartsWith(prefix))
            {
                string key = button.text.Substring(prefix.Length);
                string localized = GetLocalizedText(key);
                if (button.text != localized)
                {
                    button.text = localized;
                    updatedCount++;
                }
            }
        });

        // ── TEXTFIELDS (label) ─────────────────────────
        root.Query<TextField>().ForEach(textField =>
        {
            if (!string.IsNullOrEmpty(textField.label) && textField.label.StartsWith(prefix))
            {
                string key = textField.label.Substring(prefix.Length);
                string localized = GetLocalizedText(key);
                if (textField.label != localized)
                {
                    textField.label = localized;
                    updatedCount++;
                }
            }
        });

        // ── TEXTFIELDS (placeholder) ───────────────────
        root.Query<TextField>().ForEach(textField =>
        {
            var placeholder = textField.Q<Label>(className: "unity-base-text-field__placeholder") 
                           ?? textField.Q<Label>(className: "unity-text-field__placeholder");
            
            if (placeholder != null && !string.IsNullOrEmpty(placeholder.text) && placeholder.text.StartsWith(prefix))
            {
                string key = placeholder.text.Substring(prefix.Length);
                string localized = GetLocalizedText(key);
                if (placeholder.text != localized)
                {
                    placeholder.text = localized;
                    updatedCount++;
                }
            }
        });

        // ── INTEGERFIELD ───────────────────────────────
        root.Query<IntegerField>().ForEach(field =>
        {
            if (!string.IsNullOrEmpty(field.label) && field.label.StartsWith(prefix))
            {
                string key = field.label.Substring(prefix.Length);
                string localized = GetLocalizedText(key);
                if (field.label != localized)
                {
                    field.label = localized;
                    updatedCount++;
                }
            }
        });

        // ── Рекурсия по детям ──────────────────────────
        foreach (VisualElement child in root.Children())
            UpdateElementsWithPrefix(child, prefix);

        if (updatedCount > 0)
        {
            Debug.Log($"Updated {updatedCount} elements in {root.name}");
        }
    }

    public SystemLanguage GetCurrentLanguage()
    {
        return _currentLanguage;
    }

    // Метод для принудительного обновления при смене сцены
    public void RefreshForNewScene()
    {
        RefreshUiDocuments();
        UpdateAllUIElements();
    }

    private void OnDestroy()
    {
        // Отписываемся от события
        if (SettingsManager.Instance != null)
        {
            SettingsManager.Instance.OnSettingsChanged -= OnSettingsChanged;
        }
    }
}
Файл: ./Scripts/Core/UI/UIResponsiveManager.cs
using UnityEngine;
using UnityEngine.UIElements;

public class UIResponsiveManager
{
    private readonly VisualElement _root;
    private readonly float[] _breakpoints = { 768f, 1280f, 1920f, 2560f, 3840f };

    public UIResponsiveManager(VisualElement root)
    {
        _root = root;
        Initialize();
    }

    private void Initialize()
    {
        _root.RegisterCallback<GeometryChangedEvent>(OnGeometryChanged);
        Debug.Log("Responsive UI manager initialized");
        HideScrollers();
        Debug.Log("Responsive UI manager hide scrollers");
    }

    private void HideScrollers()
    {
        _root.Q<ScrollView>().verticalScrollerVisibility = ScrollerVisibility.Hidden;
        _root.Q<ScrollView>().horizontalScrollerVisibility = ScrollerVisibility.Hidden;
    }

    private void OnGeometryChanged(GeometryChangedEvent evt)
    {
        UpdateResponsiveClasses();
    }

    private void UpdateResponsiveClasses()
    {
        if (_root == null) return;

        float width = _root.resolvedStyle.width;
        if (float.IsNaN(width) || width <= 0) return;

        _root.RemoveFromClassList("sm-screen");
        _root.RemoveFromClassList("md-screen");
        _root.RemoveFromClassList("lg-screen");
        _root.RemoveFromClassList("xl-screen");
        _root.RemoveFromClassList("xxl-screen");

        // Добавляем нужный
        if (width < _breakpoints[0])
            _root.AddToClassList("sm-screen");
        else if (width < _breakpoints[1])
            _root.AddToClassList("md-screen");
        else if (width < _breakpoints[2])
            _root.AddToClassList("lg-screen");
        else if (width < _breakpoints[3])
            _root.AddToClassList("xl-screen");
        else
            _root.AddToClassList("xxl-screen");

        Debug.Log($"Screen width: {width}px, Class: {GetCurrentBreakpoint(width)}");
    }

    private string GetCurrentBreakpoint(float width)
    {
        if (width < _breakpoints[0]) return "sm";
        else if (width < _breakpoints[1]) return "md";
        else if (width < _breakpoints[2]) return "lg";
        else if (width < _breakpoints[3]) return "xl";
        else return "xxl";
    }

    public void RefreshResponsiveUI()
    {
        UpdateResponsiveClasses();
    }

    public void Cleanup()
    {
        if (_root != null)
        {
            _root.UnregisterCallback<GeometryChangedEvent>(OnGeometryChanged);
        }
    }
}
Файл: ./Scripts/Core/GameSettings.cs
// Assets/Scripts/GameSettings.cs
using UnityEngine;
using System;

[Serializable]
public class GameSettings
{
    // Аудио
    public float musicVolume = 0.8f;
    public float soundVolume = 0.8f;
    // Графика
    public int resolutionIndex = 0;
    public int qualityLevel = 2;
    public bool fullscreen = true;
    // Геймплей
    public string playerName = "Player";
    public int defaultWeaponIndex = 0;
    public string selectedCharacter = "Toaster";
    // Язык
    public SystemLanguage language = SystemLanguage.Russian;
}
Файл: ./Scripts/Core/UnityMainThreadDispatcher.cs
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using UnityEngine;

public class UnityMainThreadDispatcher : MonoBehaviour
{
    private static UnityMainThreadDispatcher _instance;
    private readonly Queue<Action> _actions = new Queue<Action>();
    private static readonly object _lockObject = new object();

    public static UnityMainThreadDispatcher Instance
    {
        get
        {
            if (_instance == null)
            {
                // ФИКС: Используем FindObjectOfType только в главном потоке
                if (Application.isPlaying)
                {
                    _instance = FindObjectOfType<UnityMainThreadDispatcher>();
                    if (_instance == null)
                    {
                        var obj = new GameObject("UnityMainThreadDispatcher");
                        _instance = obj.AddComponent<UnityMainThreadDispatcher>();
                        DontDestroyOnLoad(obj);
                    }
                }
            }
            return _instance;
        }
    }

    private void Awake()
    {
        if (_instance == null)
        {
            _instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else if (_instance != this)
        {
            Destroy(gameObject);
        }
    }

    public void Enqueue(Action action)
    {
        if (action == null) return;

        // ФИКС: Проверяем, находимся ли мы уже в главном потоке
        if (Thread.CurrentThread.ManagedThreadId == 1) // Главный поток Unity обычно имеет ID = 1
        {
            action?.Invoke();
        }
        else
        {
            lock (_lockObject)
            {
                _actions.Enqueue(action);
            }
        }
    }

    private void Update()
    {
        lock (_lockObject)
        {
            while (_actions.Count > 0)
            {
                var action = _actions.Dequeue();
                try
                {
                    action?.Invoke();
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error in main thread action: {e}");
                }
            }
        }
    }

    private void OnDestroy()
    {
        if (_instance == this)
        {
            _instance = null;
        }
    }
}
Файл: ./Scripts/Core/SceneLoaderSystem.cs
﻿using Unity.Entities;
using Unity.Scenes;
using UnityEngine;
using UnityEngine.SceneManagement;
using Unity.Collections;

[WorldSystemFilter(WorldSystemFilterFlags.ServerSimulation)]  // Only on server
[UpdateInGroup(typeof(InitializationSystemGroup))]
public partial struct SceneLoaderSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        var query = SystemAPI.QueryBuilder().WithAll<StartGameCommand>().Build();
        var entities = query.ToEntityArray(Allocator.Temp);
        var count = entities.Length;

        if (count > 1)
        {
            Debug.LogWarning($"Found {count} StartGameCommand instances! Destroying extras.");
            for (int i = 1; i < count; i++)
            {
                state.EntityManager.DestroyEntity(entities[i]);
            }
        }

        if (count == 0)
        {
            entities.Dispose();
            return;
        }

        Debug.Log("SceneLoaderSystem: Loading game scenes...");

        // Загружаем сцены (Additive) only once
        if (!SceneManager.GetSceneByName("ArenaSubscene").isLoaded)
        {
            SceneManager.LoadSceneAsync("ArenaSubscene", LoadSceneMode.Additive);
        }
        if (!SceneManager.GetSceneByName("EntitiesSubscene").isLoaded)
        {
            SceneManager.LoadSceneAsync("EntitiesSubscene", LoadSceneMode.Additive);
        }
        if (!SceneManager.GetSceneByName("SystemsSubscene").isLoaded)
        {
            SceneManager.LoadSceneAsync("SystemsSubscene", LoadSceneMode.Additive);
        }

        // Уничтожаем оставшуюся команду
        state.EntityManager.DestroyEntity(entities[0]);
        entities.Dispose();

        Debug.Log("Game scenes loading started");
    }
}
Файл: ./Scripts/Core/StartupManager.cs
using UnityEngine;
using UnityEngine.SceneManagement;

public class StartupManager : MonoBehaviour
{
    [SerializeField] private string managersScene = "ManagersScene";
    [SerializeField] private string mainMenuScene = "MainMenuScene";

    private void Start()
    {
        SceneManager.LoadSceneAsync(managersScene, LoadSceneMode.Additive).completed += _ => LoadMainMenu();
    }

    private void LoadMainMenu()
    {
        SceneManager.LoadSceneAsync(mainMenuScene, LoadSceneMode.Additive);
    }
}
Файл: ./Scripts/Core/GameManager.cs
using UnityEngine;

public class GameManager : MonoBehaviour
{
    private static GameManager _instance;

    [Header("Manager Prefabs")]
    public GameObject settingsManagerPrefab;
    public GameObject localizationManagerPrefab;
    public GameObject uiManagerPrefab;

    private void Awake()
    {
        if (_instance != null)
        {
            Destroy(gameObject);
            return;
        }

        _instance = this;
        DontDestroyOnLoad(gameObject);
        InitializeManagers();
    }

    private void InitializeManagers()
    {
        CreateIfMissing<SettingsManager>(settingsManagerPrefab);
        CreateIfMissing<LocalizationManager>(localizationManagerPrefab);
        CreateIfMissing<UIManager>(uiManagerPrefab);
    }

    private void CreateIfMissing<T>(GameObject prefab) where T : MonoBehaviour
    {
        if (FindObjectOfType<T>() != null) return;

        GameObject go;
        if (prefab != null)
        {
            go = Instantiate(prefab);
        }
        else
        {
            go = new GameObject(typeof(T).Name);
            go.AddComponent<T>();
        }
        DontDestroyOnLoad(go);
    }
}
Файл: ./Scripts/Core/PlayerSpawnManager.cs
﻿using Unity.Entities;
using Unity.Transforms;
using UnityEngine;
using Unity.Collections;  // Для FixedString128Bytes

public class PlayerSpawnManager : MonoBehaviour
{
    private Entity prefabEntity;
    private EntityManager entityManager;

    void Start()
    {
        entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;

        // 1. Пытаемся найти из SubScene
        var query = entityManager.CreateEntityQuery(typeof(PlayerPrefabComponent));
        if (!query.IsEmptyIgnoreFilter)
        {
            var prefabComp = entityManager.GetComponentData<PlayerPrefabComponent>(query.GetSingletonEntity());
            prefabEntity = prefabComp.Prefab;
            Debug.Log("Player prefab loaded from SubScene.");
            return;
        }

        // 2. Если SubScene не загружена — создаём вручную
        Debug.Log("SubScene not loaded yet. Creating player prefab manually.");
        prefabEntity = entityManager.CreateEntity();
        entityManager.AddComponentData(prefabEntity, LocalTransform.FromPosition(Vector3.zero));
        entityManager.AddComponentData(prefabEntity, new PlayerComponent
        {
            Name = new FixedString128Bytes("Player"),
            ConnectionId = 0,
            Ping = 0
        });

        // Singleton для совместимости
        var singletonEntity = entityManager.CreateEntity();
        entityManager.AddComponentData(singletonEntity, new PlayerPrefabComponent { Prefab = prefabEntity });
    }

    public void SpawnPlayer(ulong connectionId, Vector3 spawnPoint)
    {
        if (prefabEntity == Entity.Null)
        {
            Debug.LogError("Player prefab not initialized!");
            return;
        }

        var playerEntity = entityManager.Instantiate(prefabEntity);
        entityManager.SetComponentData(playerEntity, LocalTransform.FromPosition(spawnPoint));
        entityManager.SetComponentData(playerEntity, new PlayerComponent
        {
            Name = new FixedString128Bytes("Player_" + connectionId),
            ConnectionId = connectionId,
            Ping = 0
        });
        Debug.Log($"Player spawned: ID={connectionId} at {spawnPoint}");
    }
}
Файл: ./Scripts/MenuFeature/UI/UILobbySetupManager.cs
using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.InputSystem;
using System.Collections.Generic;

public class UILobbySetupManager
{
    private readonly VisualElement _root;
    private readonly MainMenuController _controller;

    // UI Elements
    private Slider _playerCountSlider;
    private Label _playerCountValue;
    private Slider _waveCountSlider;
    private Label _waveCountValue;
    private RadioButton _waveCountRadio;
    private RadioButton _infinityRadio;
    private RadioButton _radioOpen;
    private RadioButton _radioClosed;
    private TextField _lobbyNameField; // <-- раньше playerNameField — теперь это название лобби
    private TextField _lobbyPassword;
    private Button _togglePasswordBtn;
    private Button _randomNameBtn;
    private bool _isPasswordVisible = false;

    public UILobbySetupManager(VisualElement root, MainMenuController controller)
    {
        _root = root;
        _controller = controller;
        Initialize();
    }

    private void Initialize()
    {
        FindUIElements();
        SetupSliders();
        SetupRadioButtons();
        SetupPasswordField();
        SetupTextFields();
        SetupRandomNameButton();
        Debug.Log("UILobbySetupManager initialized (lobby-name semantics)");
    }

    private void FindUIElements()
    {
        _playerCountSlider = _root.Q<Slider>("playerCountSlider");
        _playerCountValue = _root.Q<Label>("playerCountValue");
        _waveCountSlider = _root.Q<Slider>("waveCountSlider");
        _waveCountValue = _root.Q<Label>("waveCountValue");
        _waveCountRadio = _root.Q<RadioButton>("waveCountRadio");
        _infinityRadio = _root.Q<RadioButton>("infinityRadio");
        _radioOpen = _root.Q<RadioButton>("radioOpen");
        _radioClosed = _root.Q<RadioButton>("radioClosed");
        _lobbyNameField = _root.Q<TextField>("playerNameField"); // NOTE: в UXML всё ещё name="playerNameField", но семантика — lobby name
        _lobbyPassword = _root.Q<TextField>("lobbyPassword");
        _togglePasswordBtn = _root.Q<Button>("togglePasswordVisibility");
        _randomNameBtn = _root.Q<Button>("randomNameBtn");
    }

    private void SetupTextFields()
    {
        if (_lobbyNameField != null)
        {
            _lobbyNameField.RegisterCallback<FocusInEvent>(evt => OnTextFieldFocus(_lobbyNameField, true));
            _lobbyNameField.RegisterCallback<FocusOutEvent>(evt => OnTextFieldFocus(_lobbyNameField, false));
            SetupTextFieldStyle(_lobbyNameField);
        }

        if (_lobbyPassword != null)
        {
            _lobbyPassword.RegisterCallback<FocusInEvent>(evt => OnTextFieldFocus(_lobbyPassword, true));
            _lobbyPassword.RegisterCallback<FocusOutEvent>(evt => OnTextFieldFocus(_lobbyPassword, false));
            SetupTextFieldStyle(_lobbyPassword);
        }
    }

    private void SetupTextFieldStyle(TextField textField)
    {
        textField.style.color = new StyleColor(Color.white);
        textField.style.opacity = 1f;

        var textInput = textField.Q(className: "unity-base-text-field__input");
        if (textInput != null)
        {
            textInput.style.color = new StyleColor(Color.white);
            textInput.style.opacity = 1f;
            textInput.style.backgroundColor = new StyleColor(Color.clear);
        }
    }

    private void OnTextFieldFocus(TextField textField, bool focused)
    {
        Debug.Log($"TextField {textField.name} focused: {focused}");
    }

    private void SetupRandomNameButton()
    {
        if (_randomNameBtn != null)
        {
            _randomNameBtn.clicked += OnRandomNameClicked;
        }
    }

    private void OnRandomNameClicked()
    {
        if (_lobbyNameField != null)
        {
            _lobbyNameField.value = GenerateRandomLobbyName();
        }
    }

    private string GenerateRandomLobbyName()
    {
        // Генерация названия лобби (короткое и читаемое)
        string[] prefixes = { "Alpha", "Bravo", "Gamma", "Delta", "Echo", "Orbit", "Neon" };
        string[] suffixes = { "Room", "Lobby", "Match", "Arena", "Zone" };
        return prefixes[Random.Range(0, prefixes.Length)] + " " + suffixes[Random.Range(0, suffixes.Length)] + "-" + Random.Range(1, 999).ToString();
    }

    #region Sliders
    private void SetupSliders()
    {
        SetupPlayerCountSlider();
        SetupWaveCountSlider();
    }

    private void SetupPlayerCountSlider()
    {
        if (_playerCountSlider != null && _playerCountValue != null)
        {
            _playerCountSlider.RegisterValueChangedCallback(OnPlayerCountChanged);
            UpdatePlayerCountValue(_playerCountSlider.value);
        }
    }

    private void SetupWaveCountSlider()
    {
        if (_waveCountSlider != null && _waveCountValue != null)
        {
            _waveCountSlider.lowValue = 10;
            _waveCountSlider.highValue = 50;
            _waveCountSlider.value = 10;

            _waveCountSlider.RegisterValueChangedCallback(OnWaveCountChanged);
            UpdateWaveCountValue(_waveCountSlider.value);
        }
    }

    private void OnPlayerCountChanged(ChangeEvent<float> evt)
    {
        UpdatePlayerCountValue(evt.newValue);
    }

    private void OnWaveCountChanged(ChangeEvent<float> evt)
    {
        float roundedValue = Mathf.Round(evt.newValue / 10f) * 10f;
        if (Mathf.Abs(roundedValue - evt.newValue) > 0.1f)
        {
            _waveCountSlider.value = roundedValue;
        }
        UpdateWaveCountValue(_waveCountSlider.value);
    }

    private void UpdatePlayerCountValue(float value)
    {
        if (_playerCountValue != null)
        {
            _playerCountValue.text = Mathf.RoundToInt(value).ToString();
        }
    }

    private void UpdateWaveCountValue(float value)
    {
        if (_waveCountValue != null)
        {
            _waveCountValue.text = Mathf.RoundToInt(value).ToString();
        }
    }
    #endregion

    #region Radio Buttons
    private void SetupRadioButtons()
    {
        SetupWaveRadioButtons();
        SetupLobbyRadioButtons();
    }

    private void SetupWaveRadioButtons()
    {
        if (_waveCountRadio != null && _infinityRadio != null)
        {
            _waveCountRadio.SetValueWithoutNotify(false);
            _infinityRadio.SetValueWithoutNotify(false);

            _waveCountRadio.RegisterValueChangedCallback(evt =>
            {
                if (evt.newValue)
                {
                    _infinityRadio.SetValueWithoutNotify(false);
                    if (_waveCountSlider != null)
                        _waveCountSlider.SetEnabled(true);
                }
                else if (!_infinityRadio.value)
                {
                    _waveCountRadio.SetValueWithoutNotify(true);
                }
            });

            _infinityRadio.RegisterValueChangedCallback(evt =>
            {
                if (evt.newValue)
                {
                    _waveCountRadio.SetValueWithoutNotify(false);
                    if (_waveCountSlider != null)
                        _waveCountSlider.SetEnabled(false);
                }
                else if (!_waveCountRadio.value)
                {
                    _infinityRadio.SetValueWithoutNotify(true);
                }
            });

            _waveCountRadio.value = true;
            _infinityRadio.value = false;
            if (_waveCountSlider != null)
                _waveCountSlider.SetEnabled(true);
        }
    }

    private void SetupLobbyRadioButtons()
    {
        if (_radioOpen != null && _radioClosed != null)
        {
            _radioOpen.SetValueWithoutNotify(false);
            _radioClosed.SetValueWithoutNotify(false);

            _radioOpen.RegisterValueChangedCallback(evt =>
            {
                if (evt.newValue)
                {
                    _radioClosed.SetValueWithoutNotify(false);
                    if (_lobbyPassword != null && _lobbyPassword.parent != null)
                        _lobbyPassword.parent.style.display = DisplayStyle.None;
                }
                else if (!_radioClosed.value)
                {
                    _radioOpen.SetValueWithoutNotify(true);
                }
            });

            _radioClosed.RegisterValueChangedCallback(evt =>
            {
                if (evt.newValue)
                {
                    _radioOpen.SetValueWithoutNotify(false);
                    if (_lobbyPassword != null && _lobbyPassword.parent != null)
                        _lobbyPassword.parent.style.display = DisplayStyle.Flex;
                }
                else if (!_radioOpen.value)
                {
                    _radioClosed.SetValueWithoutNotify(true);
                }
            });

            _radioOpen.value = true;
            _radioClosed.value = false;
            if (_lobbyPassword != null && _lobbyPassword.parent != null)
                _lobbyPassword.parent.style.display = DisplayStyle.None;
        }
    }
    #endregion

    #region Password Field
    private void SetupPasswordField()
    {
        if (_togglePasswordBtn != null)
        {
            _togglePasswordBtn.clicked += TogglePasswordVisibility;
            UpdatePasswordEyeIcon();
        }
    }

    public void TogglePasswordVisibility()
    {
        _isPasswordVisible = !_isPasswordVisible;
        if (_lobbyPassword != null)
        {
            _lobbyPassword.isPasswordField = !_isPasswordVisible;
        }
        UpdatePasswordEyeIcon();
    }

    private void UpdatePasswordEyeIcon()
    {
        if (_togglePasswordBtn == null) return;

        if (_isPasswordVisible)
        {
            _togglePasswordBtn.RemoveFromClassList("show-password");
            _togglePasswordBtn.AddToClassList("show-password");
        }
        else
        {
            _togglePasswordBtn.RemoveFromClassList("show-password");
        }
    }
    #endregion

    #region Debug Methods
    public void DebugTextFieldState(TextField textField, string fieldName)
    {
        if (textField == null)
        {
            Debug.LogError($"{fieldName} is null!");
            return;
        }

        Debug.Log($"=== {fieldName} State ===");
        Debug.Log($"- Display: {textField.resolvedStyle.display}");
        Debug.Log($"- Visibility: {textField.resolvedStyle.visibility}");
        Debug.Log($"- Opacity: {textField.resolvedStyle.opacity}");
        Debug.Log($"- Enabled: {textField.enabledSelf}");
        Debug.Log($"- Focusable: {textField.focusable}");
        Debug.Log($"- Value: '{textField.value}'");

        var inputElement = textField.Q(className: "unity-base-text-field__input");
        if (inputElement != null)
        {
            Debug.Log($"- Input Display: {inputElement.resolvedStyle.display}");
            Debug.Log($"- Input Color: {inputElement.resolvedStyle.color}");
        }
        else
        {
            Debug.LogError("- Input element not found!");
        }

        Debug.Log($"=== End {fieldName} State ===\n");
    }
    #endregion

    // Данные для создания лобби
    public LobbyData GetLobbyData()
    {
        return new LobbyData
        {
            name = _lobbyNameField?.value ?? "Default Lobby",
            password = _radioClosed != null && _radioClosed.value ? _lobbyPassword?.value ?? "" : "",
            maxPlayers = Mathf.RoundToInt(_playerCountSlider != null ? _playerCountSlider.value : 4),
            isOpen = _radioOpen != null ? _radioOpen.value : true
        };
    }

    // Возвращает название лобби (ранее поле использовалось как player name)
    public string GetLobbyName()
    {
        return _lobbyNameField?.value ?? "Default Lobby";
    }
}

Файл: ./Scripts/MenuFeature/UI/UICharacterSelectionManager.cs
using UnityEngine;
using UnityEngine.UIElements;

public class UICharacterSelectionManager
{
    private readonly VisualElement _root;

    // Character Elements
    private VisualElement _charVacuum;
    private VisualElement _charToaster;
    private VisualElement _charGPT;

    public UICharacterSelectionManager(VisualElement root)
    {
        _root = root;
        Initialize();
    }

    private void Initialize()
    {
        FindCharacterElements();
        SetupCharacterSelection();
    }

    private void FindCharacterElements()
    {
        _charVacuum = _root.Q<VisualElement>("charVacuum");
        _charToaster = _root.Q<VisualElement>("charToaster");
        _charGPT = _root.Q<VisualElement>("charGPT");
    }

    private void SetupCharacterSelection()
    {
        _charVacuum?.RegisterCallback<ClickEvent>(evt => SelectCharacter(_charVacuum));
        _charToaster?.RegisterCallback<ClickEvent>(evt => SelectCharacter(_charToaster));
        _charGPT?.RegisterCallback<ClickEvent>(evt => SelectCharacter(_charGPT));
    }

    private void SelectCharacter(VisualElement selectedCharacter)
    {
        _charVacuum?.RemoveFromClassList("selected");
        _charToaster?.RemoveFromClassList("selected");
        _charGPT?.RemoveFromClassList("selected");

        selectedCharacter.AddToClassList("selected");
    }

    public string GetSelectedCharacter()
    {
        if (_charVacuum?.ClassListContains("selected") == true) return "Vacuum";
        if (_charToaster?.ClassListContains("selected") == true) return "Toaster";
        if (_charGPT?.ClassListContains("selected") == true) return "GPT";
        return "None";
    }
}
Файл: ./Scripts/MenuFeature/UI/UIInputManager.cs
using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.InputSystem;
using System.Collections.Generic;

public class UIInputManager
{
    private readonly InputActionAsset _inputActions;
    private readonly VisualElement _root;
    private InputActionMap _uiActionMap;
    private InputAction _navigateAction, _submitAction, _cancelAction;
    private InputAction _openSettingsAction, _openStatisticsAction, _tabAction;
    private bool _isTextFieldFocused = false;
    private VisualElement _currentlyFocusedElement;
    private bool _isSettingFocus = false;
    private bool _cancelSubscribed = false;
    private bool _navigateSubscribed = false;
    private bool _submitSubscribed = false;
    private bool _tabSubscribed = false;
    private bool _settingsSubscribed = false;
    private bool _statsSubscribed = false;
    private UIScreenManager _screenManager;
    private MainMenuController _controller;

    public UIInputManager(InputActionAsset inputActions, VisualElement root, MainMenuController controller)
    {
        _inputActions = inputActions;
        _root = root;
        _controller = controller;
        _screenManager = new UIScreenManager(root, controller);
        Initialize();
    }

    private void Initialize()
    {
        if (_inputActions == null)
        {
            Debug.LogWarning("InputActionAsset is not assigned!");
            return;
        }
        _uiActionMap = _inputActions.FindActionMap("UI");
        if (_uiActionMap == null)
        {
            Debug.LogError("UI Action Map not found!");
            return;
        }
        SetupInputActions();
        SubscribeToInputEvents();
    }

    private void SetupInputActions()
    {
        _navigateAction = _uiActionMap.FindAction("Navigate");
        _submitAction = _uiActionMap.FindAction("Submit");
        _cancelAction = _uiActionMap.FindAction("Cancel");
        _openSettingsAction = _uiActionMap.FindAction("OpenSettings");
        _openStatisticsAction = _uiActionMap.FindAction("OpenStatistics");
        _tabAction = _uiActionMap.FindAction("Tab");
    }

    private void SubscribeToInputEvents()
    {
        if (_cancelAction != null)
        {
            _cancelAction.performed += OnCancelPerformed;
            _cancelSubscribed = true;
        }
        if (_navigateAction != null)
        {
            _navigateAction.performed += OnNavigatePerformed;
            _navigateSubscribed = true;
        }
        if (_submitAction != null)
        {
            _submitAction.performed += OnSubmitPerformed;
            _submitSubscribed = true;
        }
        if (_tabAction != null)
        {
            _tabAction.performed += OnTabPerformed;
            _tabSubscribed = true;
        }
        if (_openSettingsAction != null)
        {
            _openSettingsAction.performed += OnOpenSettingsPerformed;
            _settingsSubscribed = true;
        }
        if (_openStatisticsAction != null)
        {
            _openStatisticsAction.performed += OnOpenStatisticsPerformed;
            _statsSubscribed = true;
        }
    }

    public void Cleanup()
    {
        if (_cancelSubscribed && _cancelAction != null) _cancelAction.performed -= OnCancelPerformed;
        if (_navigateSubscribed && _navigateAction != null) _navigateAction.performed -= OnNavigatePerformed;
        if (_submitSubscribed && _submitAction != null) _submitAction.performed -= OnSubmitPerformed;
        if (_tabSubscribed && _tabAction != null) _tabAction.performed -= OnTabPerformed;
        if (_settingsSubscribed && _openSettingsAction != null) _openSettingsAction.performed -= OnOpenSettingsPerformed;
        if (_statsSubscribed && _openStatisticsAction != null) _openStatisticsAction.performed -= OnOpenStatisticsPerformed;

        _cancelSubscribed = _navigateSubscribed = _submitSubscribed = _tabSubscribed = _settingsSubscribed = _statsSubscribed = false;
    }

    public void Enable()
    {
        _inputActions?.Disable();
        _uiActionMap?.Enable();
    }

    public void Disable() => _uiActionMap?.Disable();

    private void OnCancelPerformed(InputAction.CallbackContext ctx)
    {
        if (!ctx.performed || _isTextFieldFocused) return;
        HandleEscapeKey();
    }

    private void OnNavigatePerformed(InputAction.CallbackContext ctx)
    {
        if (_isSettingFocus || _isTextFieldFocused) return;
        Vector2 dir = ctx.ReadValue<Vector2>();
        if (Mathf.Abs(dir.y) > 0.1f) NavigateUI(Mathf.RoundToInt(-dir.y));
        else if (Mathf.Abs(dir.x) > 0.1f) NavigateHorizontal(Mathf.RoundToInt(dir.x));
    }

    private void OnTabPerformed(InputAction.CallbackContext ctx)
    {
        if (!ctx.performed || _isTextFieldFocused) return;
        NavigateUI(1);
    }

    private void OnSubmitPerformed(InputAction.CallbackContext ctx)
    {
        if (!ctx.performed || _isTextFieldFocused) return;
        if (_currentlyFocusedElement is Button btn && btn.enabledSelf)
            HandleButtonClick(btn);
    }

    private void OnOpenSettingsPerformed(InputAction.CallbackContext ctx)
    {
        if (!ctx.performed || _isTextFieldFocused) return;
        string current = _screenManager.GetCurrentScreen();
        if (current != UIScreenManager.SettingsScreenName)
            _controller.ShowScreen(UIScreenManager.SettingsScreenName);
        else
            _screenManager.ReturnToMainMenu();
    }

    private void OnOpenStatisticsPerformed(InputAction.CallbackContext ctx)
    {
        if (!ctx.performed || _isTextFieldFocused) return;
        Debug.Log("Open Statistics");
        // _controller.ShowScreen("statistics_screen");
    }

    private void NavigateUI(int direction)
    {
        var elements = GetInteractiveElements();
        if (elements.Count == 0) return;
        int current = _currentlyFocusedElement != null ? elements.IndexOf(_currentlyFocusedElement) : -1;
        int next = (current + direction + elements.Count) % elements.Count;
        SetFocusToElement(elements[next]);
    }

    private void NavigateHorizontal(int direction)
    {
        // Implement horizontal navigation if needed
    }

    private List<VisualElement> GetInteractiveElements()
    {
        var list = new List<VisualElement>();
        list.AddRange(_root.Query<Button>().Where(b => b.enabledSelf && b.visible && b.focusable && b.resolvedStyle.display == DisplayStyle.Flex).ToList());
        list.AddRange(_root.Query<TextField>().Where(t => t.enabledSelf && t.visible && t.focusable && t.resolvedStyle.display == DisplayStyle.Flex).ToList());
        list.AddRange(_root.Query<RadioButton>().Where(r => r.enabledSelf && r.visible && r.focusable && r.resolvedStyle.display == DisplayStyle.Flex).ToList());
        return list;
    }

    private void SetFocusToElement(VisualElement el)
    {
        if (_isSettingFocus || el == null) return;
        _isSettingFocus = true;
        try
        {
            _currentlyFocusedElement?.Blur();
            _currentlyFocusedElement?.RemoveFromClassList("focused");
            _currentlyFocusedElement = el;
            el.focusable = true;
            el.Focus();
            el.AddToClassList("focused");
            if (el is TextField tf)
            {
                _isTextFieldFocused = true;
                tf.Q<TextElement>().style.color = Color.white;
            }
            else
            {
                _isTextFieldFocused = false;
            }
        }
        finally
        {
            _isSettingFocus = false;
        }
    }

    private void HandleButtonClick(Button btn)
    {
        switch (btn.name)
        {
            case "btnSingle": OnSinglePlayer(); break;
            case "btnCreateLobby": OnCreateLobby(); break;
            case "btnStatistics": OnStatistics(); break;
            case "btnQuit": OnQuit(); break;
            default: SimulateButtonClick(btn); break;
        }
    }

    private void SimulateButtonClick(Button btn)
    {
        using var e = NavigationSubmitEvent.GetPooled();
        e.target = btn;
        btn.SendEvent(e);
    }

    private void HandleEscapeKey()
    {
        string screen = _screenManager.GetCurrentScreen();
        if (screen == UIScreenManager.LobbyListScreenName || screen == UIScreenManager.SettingsScreenName)
            _screenManager.ReturnToMainMenu();
    }

    private void OnSinglePlayer()
    {
        SwitchToPlayerInput();
        _controller.ShowScreen(UIScreenManager.MenuScreenName);
    }

    private void OnCreateLobby()
    {
        _controller.ShowScreen(UIScreenManager.LobbyListScreenName);
    }

    private void OnStatistics() => Debug.Log("Statistics");
    private void OnQuit() => Debug.Log("Quit");

    public void SwitchToPlayerInput()
    {
        _uiActionMap?.Disable();
        var playerMap = _inputActions.FindActionMap("Player");
        playerMap?.Enable();
    }

    public void SwitchToUIInput()
    {
        var playerMap = _inputActions.FindActionMap("Player");
        playerMap?.Disable();
        _uiActionMap?.Enable();
    }
}
Файл: ./Scripts/MenuFeature/UI/SettingsManager.cs
// Assets/Scripts/UI/SettingsManager.cs
using UnityEngine;
using System;

public class SettingsManager : MonoBehaviour
{
    public static SettingsManager Instance { get; private set; }

    public GameSettings CurrentSettings { get; private set; }
    public event Action<GameSettings> OnSettingsChanged;

    private const string SETTINGS_KEY = "GameSettings";

    [Header("Debug")]
    [SerializeField] private bool debugMode = true;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            LoadSettings();

            if (debugMode)
            {
                Debug.Log("=== SettingsManager Initialized ===");
                Debug.Log($"Instance: {Instance != null}");
                Debug.Log($"CurrentSettings: {CurrentSettings != null}");
                Debug.Log($"Language: {CurrentSettings?.language}");
            }
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void LoadSettings()
    {
        string json = PlayerPrefs.GetString(SETTINGS_KEY, "");

        if (!string.IsNullOrEmpty(json))
        {
            try
            {
                CurrentSettings = JsonUtility.FromJson<GameSettings>(json);
                if (debugMode) Debug.Log("Settings loaded from PlayerPrefs");
            }
            catch (Exception e)
            {
                Debug.LogError($"Error loading settings: {e.Message}");
                CreateDefaultSettings();
            }
        }
        else
        {
            CreateDefaultSettings();
            if (debugMode) Debug.Log("Default settings created");
        }

        ApplySettings();
    }

    private void CreateDefaultSettings()
    {
        CurrentSettings = new GameSettings();
        // Определяем язык системы
        CurrentSettings.language = Application.systemLanguage == SystemLanguage.Russian ?
            SystemLanguage.Russian : SystemLanguage.English;

        if (debugMode) Debug.Log($"Default language set to: {CurrentSettings.language}");
    }

    public void SaveSettings(GameSettings newSettings)
    {
        if (newSettings == null)
        {
            Debug.LogError("Cannot save null settings!");
            return;
        }

        CurrentSettings = newSettings;
        string json = JsonUtility.ToJson(CurrentSettings);
        PlayerPrefs.SetString(SETTINGS_KEY, json);
        PlayerPrefs.Save();

        ApplySettings();
        OnSettingsChanged?.Invoke(CurrentSettings);

        if (debugMode)
        {
            Debug.Log("=== Settings Saved ===");
            Debug.Log($"Language: {CurrentSettings.language}");
            Debug.Log($"Music: {CurrentSettings.musicVolume}, Sound: {CurrentSettings.soundVolume}");
            Debug.Log($"Player: {CurrentSettings.playerName}");
        }
    }

    private void ApplySettings()
    {
        if (CurrentSettings == null)
        {
            Debug.LogError("CurrentSettings is null!");
            return;
        }

        // Применяем настройки аудио
        AudioListener.volume = CurrentSettings.soundVolume;

        // Применяем настройки графики
        if (CurrentSettings.qualityLevel >= 0 && CurrentSettings.qualityLevel < QualitySettings.names.Length)
        {
            QualitySettings.SetQualityLevel(CurrentSettings.qualityLevel);
        }

        Screen.fullScreen = CurrentSettings.fullscreen;

        // Применяем язык - ВАЖНО: всегда применяем язык, даже если LocalizationManager еще не готов
        ApplyLanguage();

        // Применяем разрешение экрана
        ApplyResolution();
    }

    private void ApplyLanguage()
    {
        if (LocalizationManager.Instance != null)
        {
            // Всегда принудительно обновляем язык
            LocalizationManager.Instance.LoadLanguage(CurrentSettings.language, true);
            Debug.Log($"Language applied: {CurrentSettings.language}");
        }
        else
        {
            Debug.LogWarning("LocalizationManager not found, retrying...");
            // Пробуем еще раз через кадр
            StartCoroutine(DelayedLanguageApply());
        }
    }

    private System.Collections.IEnumerator DelayedLanguageApply()
    {
        yield return new WaitForEndOfFrame();
        
        if (LocalizationManager.Instance != null)
        {
            LocalizationManager.Instance.LoadLanguage(CurrentSettings.language, true);
            Debug.Log($"Language applied after delay: {CurrentSettings.language}");
        }
        else
        {
            Debug.LogError("LocalizationManager still not found after delay!");
        }
    }

    private void ApplyResolution()
    {
        Resolution[] resolutions = Screen.resolutions;
        if (CurrentSettings.resolutionIndex >= 0 && CurrentSettings.resolutionIndex < resolutions.Length)
        {
            Resolution resolution = resolutions[CurrentSettings.resolutionIndex];
            Screen.SetResolution(resolution.width, resolution.height, CurrentSettings.fullscreen);

            if (debugMode) Debug.Log($"Resolution set to: {resolution.width}x{resolution.height}");
        }
    }

    // Метод для быстрого доступа из других скриптов
    public static bool IsReady()
    {
        return Instance != null && Instance.CurrentSettings != null;
    }
}
Файл: ./Scripts/MenuFeature/UI/UIScreenManager.cs
using UnityEngine;
using UnityEngine.SceneManagement;
using Unity.NetCode;
using UnityEngine.UIElements;
using System.Collections;
using System.Collections.Generic;
using Unity.Collections;

public class UIScreenManager
{
    public const string MenuScreenName = "menu_screen";
    public const string SettingsScreenName = "settings_screen";
    public const string LobbyListScreenName = "lobby_list_screen";
    public const string LobbySettingsScreenName = "lobby_settings_screen";
    private Button _btnRefreshLobbyList;

    private readonly VisualElement _root;
    private readonly MainMenuController _controller;
    private string _currentScreen = MenuScreenName;

    // UI Elements
    private Button _btnShowLobbyList;
    private Button _btnCreateLobby;
    private Button _btnDisbandLobby;
    private Button _btnStartGame;
    private ScrollView _lobbyListScroll;
    private ScrollView _playersScroll;

    private bool _isProcessingDisband = false;

    public UIScreenManager(VisualElement root, MainMenuController controller)
    {
        _root = root;
        _controller = controller;
        InitializeButtons();
        SetupCallbacks();

        // Подписываемся на обновления списка лобби
        if (LobbyDiscovery.Instance != null)
        {
            LobbyDiscovery.Instance.OnLobbiesUpdated += OnLobbiesUpdated;
            LobbyDiscovery.Instance.OnLobbyClosed += OnLobbyClosed;
        }
    }

    public string GetCurrentScreen() => _currentScreen;

    public void OnLobbyClosed(string lobbyId)
    {
        Debug.Log($"UIScreenManager: Lobby {lobbyId} closed, current screen: {_currentScreen}");

        // ФИКС: Используем UnityMainThreadDispatcher для вызова в главном потоке
        UnityMainThreadDispatcher.Instance.Enqueue(() =>
        {
            _controller?.HandleLobbyClosed(lobbyId);
        });
    }

    private void InitializeButtons()
    {
        Debug.Log("Initializing UI buttons...");

        var menuScreen = _root.Q<VisualElement>(MenuScreenName);
        _btnShowLobbyList = menuScreen?.Q<Button>("btnShowLobbyList");
        Debug.Log($"_btnShowLobbyList found: {_btnShowLobbyList != null}");

        var lobbyListScreen = _root.Q<VisualElement>(LobbyListScreenName);
        _btnCreateLobby = lobbyListScreen?.Q<Button>("btnCreateLobby");
        _btnRefreshLobbyList = lobbyListScreen?.Q<Button>("btnRefreshLobbyList");
        _lobbyListScroll = lobbyListScreen?.Q<ScrollView>("lobbyListScroll");

        Debug.Log($"_btnCreateLobby found: {_btnCreateLobby != null}");
        Debug.Log($"_btnRefreshLobbyList found: {_btnRefreshLobbyList != null}");
        Debug.Log($"_lobbyListScroll found: {_lobbyListScroll != null}");

        var lobbySettingsScreen = _root.Q<VisualElement>(LobbySettingsScreenName);
        _playersScroll = lobbySettingsScreen?.Q<ScrollView>("playersScroll");
        _btnDisbandLobby = lobbySettingsScreen?.Q<Button>("btnDisbandLobby");
        _btnStartGame = lobbySettingsScreen?.Q<Button>("btnStartGame");

        Debug.Log("UI buttons initialization complete");
    }

    private void SetupCallbacks()
    {
        if (_btnShowLobbyList != null)
            _btnShowLobbyList.clicked += () => {
                _controller.ShowScreen(LobbyListScreenName);
                RefreshLobbyList();
            };

        if (_btnCreateLobby != null)
            _btnCreateLobby.clicked += OnCreateLobby;

        if (_btnRefreshLobbyList != null)
            _btnRefreshLobbyList.clicked += () => {
                Debug.Log("Manual lobby list refresh");
                RefreshLobbyList();
                // Принудительно отправляем DISCOVER запрос
                if (LobbyDiscovery.Instance != null)
                {
                    LobbyDiscovery.Instance.ForceDiscovery();
                }
            };

        if (_btnDisbandLobby != null)
            _btnDisbandLobby.clicked += OnDisbandLobby;

        if (_btnStartGame != null)
            _btnStartGame.clicked += () => UIManager.Instance.StartGame();

        if (LobbyDiscovery.Instance != null)
        {
            LobbyDiscovery.Instance.OnLobbiesUpdated += (lobbies) => {
                if (_currentScreen == LobbyListScreenName)
                {
                    RefreshLobbyList();
                }
            };
        }

    }

    private void OnLobbiesUpdated(List<LobbyInfo> lobbies)
    {
        Debug.Log($"UIScreenManager: OnLobbiesUpdated called with {lobbies.Count} lobbies");
        Debug.Log($"Current screen: {_currentScreen}, should be: {LobbyListScreenName}");

        // ОБНОВЛЯЕМ В ЛЮБОМ СЛУЧАЕ, ЕСЛИ МЫ НА ЭКРАНЕ СПИСКА ЛОББИ
        if (_currentScreen == LobbyListScreenName)
        {
            Debug.Log("Refreshing lobby list UI because we're on the lobby list screen");
            RefreshLobbyList();
        }
        else
        {
            Debug.Log($"Not refreshing UI because current screen is {_currentScreen}, not {LobbyListScreenName}");
            // НО СОХРАНЯЕМ ДАННЫЕ ДЛЯ БУДУЩЕГО ИСПОЛЬЗОВАНИЯ
        }
    }


    public void ShowScreen(string screenName)
    {
        Debug.Log($"ShowScreen called: {screenName}");

        var screens = _root.Query<VisualElement>(className: "screen").ToList();
        foreach (var screen in screens)
        {
            screen.style.display = screen.name == screenName ? DisplayStyle.Flex : DisplayStyle.None;
        }
        _currentScreen = screenName;

        Debug.Log($"Screen set to: {screenName}");

        if (screenName == LobbyListScreenName)
        {
            Debug.Log("On lobby list screen, refreshing list...");
            RefreshLobbyList();

            // ПРИНУДИТЕЛЬНО ОБНОВЛЯЕМ СПИСОК ЛОББИ ПРИ ПОКАЗЕ ЭКРАНА
            if (LobbyDiscovery.Instance != null)
            {
                LobbyDiscovery.Instance.ForceDiscovery();
            }
        }

        Debug.Log($"Showing screen: {screenName}");
    }

    public void RefreshLobbyList()
    {
        Debug.Log($"RefreshLobbyList called, current screen: {_currentScreen}, _lobbyListScroll is null: {_lobbyListScroll == null}");

        if (_lobbyListScroll != null)
        {
            _lobbyListScroll.Clear();
            Debug.Log("Cleared lobby list scroll");

            // Получаем lobbies напрямую из LobbyDiscovery
            var lobbies = LobbyDiscovery.Instance?.GetDiscoveredLobbies() ?? new List<LobbyInfo>();
            Debug.Log($"RefreshLobbyList: Got {lobbies.Count} lobbies from LobbyDiscovery");

            if (lobbies.Count == 0)
            {
                var noLobbies = new Label("No lobbies found. Waiting for discovery...");
                noLobbies.AddToClassList("no-lobbies-label");
                _lobbyListScroll.Add(noLobbies);
                Debug.Log("Added 'no lobbies' message");
            }
            else
            {
                foreach (var lobby in lobbies)
                {
                    Debug.Log($"RefreshLobbyList: Adding lobby to UI: {lobby.name}");
                    CreateLobbyItem(_lobbyListScroll, lobby);
                }
                Debug.Log($"Refreshed lobby list with {lobbies.Count} lobbies");
            }
        }
        else
        {
            Debug.LogError("_lobbyListScroll is null - cannot refresh lobby list");
        }
    }

    private VisualElement CreateLobbyItem(ScrollView scroll, LobbyInfo info)
    {
        var item = new VisualElement();
        item.AddToClassList("lobby-item");

        var nameLabel = new Label(info.name);
        nameLabel.AddToClassList("lobby-name");

        var playersLabel = new Label($"{info.currentPlayers}/{info.maxPlayers}");
        playersLabel.AddToClassList("lobby-players");

        var typeLabel = new Label(info.isOpen ? "Open" : "Password");
        typeLabel.AddToClassList("lobby-type");

        var joinBtn = new Button(() => {
            if (info.isOpen || string.IsNullOrEmpty(info.password))
            {
                // Сначала переключаем экран, затем присоединяемся
                _controller.OnJoinedAsClient(); // ← Новый метод
                UIManager.Instance.LobbyManager.JoinLobby(info,
                    SettingsManager.Instance.CurrentSettings.playerName,
                    info.password);
            }
            else
            {
                // Вызываем метод из LobbyManager вместо несуществующего локального метода
                UIManager.Instance.LobbyManager.ShowPasswordPrompt(info);
            }
        })
        {
            text = "Join"
        };
        joinBtn.AddToClassList("join-button");

        item.Add(nameLabel);
        item.Add(playersLabel);
        item.Add(typeLabel);
        item.Add(joinBtn);

        scroll.Add(item);
        return item;
    }

    private void OnCreateLobby()
    {
        var lobbyData = _controller.LobbySetupManager.GetLobbyData();
        // Имя игрока берём из SettingsManager — игрок не может менять параметры игры при подключении
        var playerName = SettingsManager.Instance != null ? SettingsManager.Instance.CurrentSettings.playerName : "Player";
        var selectedCharacter = _controller.CharacterSelectionManager.GetSelectedCharacter();
        var playerData = new PlayerData
        {
            name = new FixedString128Bytes(playerName),
            selectedCharacter = selectedCharacter
        };
        UIManager.Instance.LobbyManager.CreateLobby(lobbyData, playerData);
    }

    public void OnDisbandLobby()
    {
        Debug.Log("UIScreenManager: Disbanding lobby...");

        // ФИКС: Добавляем проверку чтобы предотвратить множественные вызовы
        if (_isProcessingDisband)
        {
            Debug.LogWarning("UIScreenManager: Disband already in progress, ignoring");
            return;
        }

        _isProcessingDisband = true;

        try
        {
            var lobbyManager = UIManager.Instance?.LobbyManager;
            if (lobbyManager != null)
            {
                lobbyManager.DisbandLobby();
            }

            // ФИКС: Используем MainMenuController для вызова корутины
            _controller?.ShowLobbyListAfterDisband();
        }
        finally
        {
            _isProcessingDisband = false;
        }
    }

    public void ReturnToMainMenu() => ShowScreen(MenuScreenName);

    public void UpdatePlayerList()
    {
        if (_playersScroll != null)
        {
            _playersScroll.Clear();
            UIManager.Instance.LobbyManager.PopulatePlayerList(_playersScroll);
        }
    }
}
Файл: ./Scripts/MenuFeature/UI/UISettingsManager.cs
using UnityEngine;
using UnityEngine.UIElements;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class UISettingsManager
{
    private readonly VisualElement _root;
    private readonly UIDocument _uiDocument;
    private readonly MainMenuController _controller;

    // UI Elements
    private TextField _playerNameField;
    private RadioButtonGroup _weaponRadioGroup;
    private Slider _musicSlider;
    private Label _musicValue;
    private Slider _soundSlider;
    private Label _soundValue;
    private DropdownField _resolutionDropdown;
    private DropdownField _qualityDropdown;
    private Button _btnRussian;
    private Button _btnEnglish;
    private Button _btnSaveSettings;
    private Button _btnCancelSettings;

    // Data
    private List<Resolution> _resolutions;
    private string[] _qualityNames;

    public UISettingsManager(VisualElement root, UIDocument uiDocument, MainMenuController controller)
    {
        _root = root;
        _uiDocument = uiDocument;
        _controller = controller;
        InitializeWithDelay();
    }

    private void InitializeWithDelay()
    {
        _uiDocument.StartCoroutine(InitializeCoroutine());
    }

    private IEnumerator InitializeCoroutine()
    {
        yield return null; // Ждём один кадр
        Initialize();
    }

    private void Initialize()
    {
        FindUIElements();
        SetupData();
        SetupEventHandlers();
        LoadCurrentSettings();
        Debug.Log("UISettingsManager initialized");
    }

    private void FindUIElements()
    {
        var settingsScreen = _root.Q<VisualElement>(UIScreenManager.SettingsScreenName);
        if (settingsScreen == null)
        {
            Debug.LogError($"[UISettingsManager] Экран '{UIScreenManager.SettingsScreenName}' не найден в UIDocument!");
            return;
        }

        _playerNameField = settingsScreen.Q<TextField>("playerNameField");
        if (_playerNameField == null) Debug.LogWarning("[UISettingsManager] playerNameField не найден!");

        _musicSlider = settingsScreen.Q<Slider>("musicSlider");
        _musicValue = settingsScreen.Q<Label>("musicVolumeLabel");
        _soundSlider = settingsScreen.Q<Slider>("soundVolumeSlider");
        _soundValue = settingsScreen.Q<Label>("soundVolumeLabel");
        _resolutionDropdown = settingsScreen.Q<DropdownField>("resolutionDropdown");
        _qualityDropdown = settingsScreen.Q<DropdownField>("qualityDropdown");
        _btnRussian = settingsScreen.Q<Button>("russianButton");
        _btnEnglish = settingsScreen.Q<Button>("englishButton");
        _btnSaveSettings = settingsScreen.Q<Button>("btnSave");
        _btnCancelSettings = settingsScreen.Q<Button>("cancelBtn");

        var rightPanel = settingsScreen.Q<VisualElement>("right-panel");
        if (rightPanel != null)
        {
            _weaponRadioGroup = rightPanel.Query<RadioButtonGroup>().First();
            if (_weaponRadioGroup == null)
                Debug.LogWarning("[UISettingsManager] RadioButtonGroup не найден в right-panel!");
        }
        else
        {
            Debug.LogWarning("[UISettingsManager] right-panel не найден в settings_screen!");
        }
    }

    private void SetupData()
    {
        if (_resolutionDropdown != null)
        {
            _resolutions = new List<Resolution>(Screen.resolutions);
            var options = _resolutions.Select(r => $"{r.width} x {r.height} ({r.refreshRate}Hz)").ToList();
            _resolutionDropdown.choices = options;
        }

        if (_qualityDropdown != null)
        {
            _qualityNames = QualitySettings.names;
            _qualityDropdown.choices = new List<string>(_qualityNames);
        }
    }

    private void SetupEventHandlers()
    {
        if (_musicSlider != null)
            _musicSlider.RegisterValueChangedCallback(OnMusicVolumeChanged);

        if (_soundSlider != null)
            _soundSlider.RegisterValueChangedCallback(OnSoundVolumeChanged);

        if (_btnRussian != null)
            _btnRussian.clicked += () => OnLanguageChanged(SystemLanguage.Russian);

        if (_btnEnglish != null)
            _btnEnglish.clicked += () => OnLanguageChanged(SystemLanguage.English);

        if (_btnSaveSettings != null)
            _btnSaveSettings.clicked += OnSaveSettings;

        if (_btnCancelSettings != null)
            _btnCancelSettings.clicked += OnCancelSettings;

        _root.RegisterCallback<KeyDownEvent>(OnKeyDown);
    }

    private void LoadCurrentSettings()
    {
        if (!SettingsManager.IsReady())
        {
            Debug.LogWarning("[UISettingsManager] SettingsManager не готов. Повторная попытка через 0.1с...");
            _uiDocument.StartCoroutine(RetryLoadSettings());
            return;
        }

        var s = SettingsManager.Instance.CurrentSettings;

        if (_playerNameField != null)
            _playerNameField.value = s.playerName ?? "Player";
        else
            Debug.LogWarning("[UISettingsManager] playerNameField == null → имя игрока не установлено");

        if (_weaponRadioGroup != null)
            _weaponRadioGroup.value = s.defaultWeaponIndex;
        else
            Debug.LogWarning("[UISettingsManager] weaponRadioGroup == null → оружие не выбрано");

        if (_musicSlider != null && _musicValue != null)
        {
            _musicSlider.value = s.musicVolume * 100f;
            UpdateMusicValue(s.musicVolume * 100f);
        }

        if (_soundSlider != null && _soundValue != null)
        {
            _soundSlider.value = s.soundVolume * 100f;
            UpdateSoundValue(s.soundVolume * 100f);
        }

        if (_resolutionDropdown != null && _resolutions != null && _resolutions.Count > 0)
        {
            int index = Mathf.Clamp(s.resolutionIndex, 0, _resolutions.Count - 1);
            _resolutionDropdown.index = index;
        }

        if (_qualityDropdown != null && _qualityNames != null && _qualityNames.Length > 0)
        {
            int index = Mathf.Clamp(s.qualityLevel, 0, _qualityNames.Length - 1);
            _qualityDropdown.index = index;
        }

        UpdateLanguageButtons(s.language);
    }

    private IEnumerator RetryLoadSettings()
    {
        yield return new WaitForSeconds(0.1f);
        if (SettingsManager.IsReady())
            LoadCurrentSettings();
        else
            Debug.LogError("[UISettingsManager] SettingsManager всё ещё не готов после задержки!");
    }

    private void UpdateLanguageButtons(SystemLanguage lang)
    {
        bool isRu = lang == SystemLanguage.Russian;

        if (_btnRussian != null)
        {
            _btnRussian.RemoveFromClassList("selected-language");
            if (isRu) _btnRussian.AddToClassList("selected-language");
        }

        if (_btnEnglish != null)
        {
            _btnEnglish.RemoveFromClassList("selected-language");
            if (!isRu) _btnEnglish.AddToClassList("selected-language");
        }
    }

    #region Event Handlers

    private void OnMusicVolumeChanged(ChangeEvent<float> evt)
    {
        UpdateMusicValue(evt.newValue);
    }

    private void OnSoundVolumeChanged(ChangeEvent<float> evt)
    {
        UpdateSoundValue(evt.newValue);
    }

    private void UpdateMusicValue(float v)
    {
        if (_musicValue != null)
            _musicValue.text = Mathf.RoundToInt(v).ToString();
    }

    private void UpdateSoundValue(float v)
    {
        if (_soundValue != null)
            _soundValue.text = Mathf.RoundToInt(v).ToString();
    }

    private void OnLanguageChanged(SystemLanguage lang)
    {
        UpdateLanguageButtons(lang);
        LocalizationManager.Instance?.LoadLanguage(lang, true);
    }

    private void OnSaveSettings()
    {
        if (!SettingsManager.IsReady())
        {
            Debug.LogWarning("[UISettingsManager] SettingsManager не готов → создаём временный");
            CreateEmergencySettingsManager();
            return;
        }

        var settings = CreateSettingsFromUI();
        SettingsManager.Instance.SaveSettings(settings);

        _uiDocument.StartCoroutine(DelayedReturn());
    }

    private IEnumerator DelayedReturn()
    {
        yield return new WaitForSeconds(0.1f);
        LocalizationManager.Instance?.UpdateAllUIElements();
        _controller.ShowScreen(UIScreenManager.MenuScreenName);
    }

    private void OnCancelSettings()
    {
        _controller.ShowScreen(UIScreenManager.MenuScreenName);
    }

    private void OnKeyDown(KeyDownEvent evt)
    {
        if (evt.keyCode == KeyCode.Escape)
        {
            _controller.ShowScreen(UIScreenManager.MenuScreenName);
            evt.StopPropagation();
        }
    }

    #endregion

    #region Emergency & Helpers

    private void CreateEmergencySettingsManager()
    {
        var obj = new GameObject("TempSettingsManager");
        var mgr = obj.AddComponent<SettingsManager>();
        _uiDocument.StartCoroutine(SaveWithTempManager(mgr));
    }

    private IEnumerator SaveWithTempManager(SettingsManager mgr)
    {
        yield return new WaitUntil(() => SettingsManager.IsReady());
        var settings = CreateSettingsFromUI();
        SettingsManager.Instance.SaveSettings(settings);
        Object.Destroy(mgr.gameObject);
        _controller.ShowScreen(UIScreenManager.MenuScreenName);
    }

    private GameSettings CreateSettingsFromUI()
    {
        return new GameSettings
        {
            playerName = _playerNameField?.value ?? "Player",
            defaultWeaponIndex = _weaponRadioGroup?.value ?? 0,
            musicVolume = _musicSlider != null ? _musicSlider.value / 100f : 0.8f,
            soundVolume = _soundSlider != null ? _soundSlider.value / 100f : 0.8f,
            resolutionIndex = _resolutionDropdown?.index ?? 0,
            qualityLevel = _qualityDropdown?.index ?? 2,
            language = (_btnRussian != null && _btnRussian.ClassListContains("selected-language"))
                ? SystemLanguage.Russian
                : SystemLanguage.English
        };
    }

    #endregion

    public void Cleanup()
    {
        _root.UnregisterCallback<KeyDownEvent>(OnKeyDown);

        if (_btnRussian != null)
            _btnRussian.clicked -= () => OnLanguageChanged(SystemLanguage.Russian);

        if (_btnEnglish != null)
            _btnEnglish.clicked -= () => OnLanguageChanged(SystemLanguage.English);

        if (_btnSaveSettings != null)
            _btnSaveSettings.clicked -= OnSaveSettings;

        if (_btnCancelSettings != null)
            _btnCancelSettings.clicked -= OnCancelSettings;
    }
}
Файл: ./Scripts/MenuFeature/UI/LobbySettingsManager.cs
using UnityEngine;
using UnityEngine.UIElements;

public class LobbySettingsManager
{
    private VisualElement _root;

    // Source elements from lobby_list_screen
    private TextField _createLobbyName;
    private RadioButton _radioOpen;
    private RadioButton _radioClosed;
    private TextField _lobbyPassword;
    private Slider _playerCountSlider;
    private Label _playerCountValue;
    private VisualElement _charVacuum;
    private VisualElement _charToaster;
    private VisualElement _charGPT;
    private Slider _waveCountSlider;
    private Label _waveCountValue;

    // Target elements from lobby_settings_screen
    private TextField _lobbyNameField;
    private RadioButton _settingsRadioOpen;
    private RadioButton _settingsRadioClosed;
    private TextField _lobbyPasswordField;
    private Slider _settingsPlayerCountSlider;
    private Label _settingsPlayerCountValue;
    private VisualElement _settingsCharVacuum;
    private VisualElement _settingsCharToaster;
    private VisualElement _settingsCharGPT;
    private Slider _settingsWaveCountSlider;
    private Label _settingsWaveCountValue;

    public LobbySettingsManager(VisualElement root)
    {
        _root = root;
        InitializeElements();
        SetupEventListeners();
    }

    private void InitializeElements()
    {
        var lobbyListScreen = _root.Q<VisualElement>("lobby_list_screen");
        _createLobbyName = lobbyListScreen.Q<TextField>("createLobbyName");
        _radioOpen = lobbyListScreen.Q<RadioButton>("radioOpen");
        _radioClosed = lobbyListScreen.Q<RadioButton>("radioClosed");
        _lobbyPassword = lobbyListScreen.Q<TextField>("lobbyPassword");
        _playerCountSlider = lobbyListScreen.Q<Slider>("playerCountSlider");
        _playerCountValue = lobbyListScreen.Q<Label>("playerCountValue");
        _charVacuum = lobbyListScreen.Q<VisualElement>("charVacuum");
        _charToaster = lobbyListScreen.Q<VisualElement>("charToaster");
        _charGPT = lobbyListScreen.Q<VisualElement>("charGPT");
        _waveCountSlider = lobbyListScreen.Q<Slider>("waveCountSlider");
        _waveCountValue = lobbyListScreen.Q<Label>("waveCountValue");

        var lobbySettingsScreen = _root.Q<VisualElement>("lobby_settings_screen");
        _lobbyNameField = lobbySettingsScreen.Q<TextField>("lobbyNameField");
        _settingsRadioOpen = lobbySettingsScreen.Q<RadioButton>("radioOpen");
        _settingsRadioClosed = lobbySettingsScreen.Q<RadioButton>("radioClosed");
        _lobbyPasswordField = lobbySettingsScreen.Q<TextField>("lobbyPasswordField");
        _settingsPlayerCountSlider = lobbySettingsScreen.Q<Slider>("playerCountSlider");
        _settingsPlayerCountValue = lobbySettingsScreen.Q<Label>("playerCountValue");
        _settingsCharVacuum = lobbySettingsScreen.Q<VisualElement>("charVacuum");
        _settingsCharToaster = lobbySettingsScreen.Q<VisualElement>("charToaster");
        _settingsCharGPT = lobbySettingsScreen.Q<VisualElement>("charGPT");
        _settingsWaveCountSlider = lobbySettingsScreen.Q<Slider>("waveCountSlider");
        _settingsWaveCountValue = lobbySettingsScreen.Q<Label>("waveCountValue");
    }

    private void SetupEventListeners()
    {
        _createLobbyName?.RegisterValueChangedCallback(evt => SyncLobbyName());
        _radioOpen?.RegisterValueChangedCallback(evt => SyncLobbyType());
        _radioClosed?.RegisterValueChangedCallback(evt => SyncLobbyType());
        _lobbyPassword?.RegisterValueChangedCallback(evt => SyncPassword());
        _playerCountSlider?.RegisterValueChangedCallback(evt => SyncPlayerCount());
        _waveCountSlider?.RegisterValueChangedCallback(evt => SyncWaveCount());
    }

    public void SyncAllSettings()
    {
        SyncLobbyName();
        SyncLobbyType();
        SyncPassword();
        SyncPlayerCount();
        SyncCharacterSelection();
        SyncWaveCount();
    }

    private void SyncLobbyName()
    {
        if (_lobbyNameField != null && _createLobbyName != null)
            _lobbyNameField.value = _createLobbyName.value;
    }

    private void SyncLobbyType()
    {
        _settingsRadioOpen?.SetValueWithoutNotify(_radioOpen?.value ?? false);
        _settingsRadioClosed?.SetValueWithoutNotify(_radioClosed?.value ?? false);
    }

    private void SyncPassword()
    {
        if (_lobbyPasswordField != null && _lobbyPassword != null)
            _lobbyPasswordField.value = _lobbyPassword.value;
    }

    private void SyncPlayerCount()
    {
        _settingsPlayerCountSlider?.SetValueWithoutNotify(_playerCountSlider?.value ?? 4);
        _settingsPlayerCountValue.text = _playerCountValue?.text;
    }

    private void SyncCharacterSelection()
    {
        _settingsCharVacuum?.RemoveFromClassList("selected");
        _settingsCharToaster?.RemoveFromClassList("selected");
        _settingsCharGPT?.RemoveFromClassList("selected");

        if (_charVacuum?.ClassListContains("selected") == true) _settingsCharVacuum?.AddToClassList("selected");
        else if (_charToaster?.ClassListContains("selected") == true) _settingsCharToaster?.AddToClassList("selected");
        else if (_charGPT?.ClassListContains("selected") == true) _settingsCharGPT?.AddToClassList("selected");
    }

    private void SyncWaveCount()
    {
        _settingsWaveCountSlider?.SetValueWithoutNotify(_waveCountSlider?.value ?? 10);
        _settingsWaveCountValue.text = _waveCountValue?.text;
    }
}
Файл: ./Scripts/MenuFeature/UI/MainMenuController.cs
using UnityEngine;
using UnityEngine.UIElements;
using System.Collections;

public class MainMenuController : MonoBehaviour
{
    private VisualElement _root;
    private UIInputManager _inputManager;
    private UIScreenManager _screenManager;
    private UILobbySetupManager _lobbySetup;
    private UICharacterSelectionManager _charSelect;
    private UISettingsManager _settings;
    private LobbySettingsManager _lobbySettings;

    public UILobbySetupManager LobbySetupManager => _lobbySetup;
    public UICharacterSelectionManager CharacterSelectionManager => _charSelect;

    private void Start()
    {
        var uiDoc = GetComponent<UIDocument>();
        _root = uiDoc.rootVisualElement;

        _inputManager = new UIInputManager(UIManager.Instance.InputActions, _root, this);
        _screenManager = new UIScreenManager(_root, this);
        _lobbySetup = new UILobbySetupManager(_root, this);
        _charSelect = new UICharacterSelectionManager(_root);
        _settings = new UISettingsManager(_root, uiDoc, this);
        _lobbySettings = new LobbySettingsManager(_root);
        _inputManager.Enable();
        _screenManager.ShowScreen(UIScreenManager.MenuScreenName);

        LocalizationManager.Instance?.RefreshForNewScene();
        LocalizationManager.Instance?.UpdateAllUIElements();
    }

    public void ShowScreen(string screenName)
    {
        _screenManager.ShowScreen(screenName);

        if (screenName == UIScreenManager.LobbyListScreenName)
        {
            StartCoroutine(DelayedLobbyRefresh());
        }
    }

    private IEnumerator DelayedLobbyRefresh()
    {
        yield return new WaitForEndOfFrame();
        UIManager.Instance.OnLobbyListUpdated();

        LobbyDiscovery.Instance?.ForceDiscovery();
    }

    public void UpdatePlayerList()
    {
        _screenManager.UpdatePlayerList();
    }

    public void OnLobbyCreated()
    {
        ShowScreen(UIScreenManager.LobbySettingsScreenName);
        _lobbySettings.SyncAllSettings();
        UIManager.Instance.OnPlayersUpdated();
    }

    public void OnLobbyListUpdated() => _screenManager.RefreshLobbyList();

    public void OnJoinedAsClient()
    {
        ShowScreen("lobby_settings_screen");
        SetupClientModeUI();
    }

    public void SetupHostModeUI()
    {
        var lobbySettingsScreen = _root.Q<VisualElement>("lobby_settings_screen");
        if (lobbySettingsScreen == null) return;

        // Показываем все элементы для хоста
        var btnStartGame = lobbySettingsScreen.Q<Button>("btnStartGame");
        var btnDisbandLobby = lobbySettingsScreen.Q<Button>("btnDisbandLobby");
        var lobbyNameField = lobbySettingsScreen.Q<TextField>("lobbyNameField");
        var playerCountSlider = lobbySettingsScreen.Q<Slider>("playerCountSlider");

        if (btnStartGame != null) btnStartGame.style.display = DisplayStyle.Flex;
        if (btnDisbandLobby != null) btnDisbandLobby.style.display = DisplayStyle.Flex;
        if (lobbyNameField != null) lobbyNameField.SetEnabled(true);
        if (playerCountSlider != null) playerCountSlider.SetEnabled(true);

        Debug.Log("UI set to host mode - all controls enabled");
    }

    public void ReturnToLobbyList()
    {
        Debug.Log("MainMenuController: Returning to lobby list");
        ShowScreen(UIScreenManager.LobbyListScreenName);
        StartCoroutine(DelayedLobbyRefresh2());
    }

    private IEnumerator DelayedLobbyRefresh2()
    {
        yield return new WaitForSeconds(0.5f);
        UIManager.Instance?.OnLobbyListUpdated();
        LobbyDiscovery.Instance?.ForceDiscovery();
    }

    public void HandleLobbyClosed(string lobbyId)
    {
        Debug.Log($"MainMenuController: Handling lobby close for {lobbyId}, current screen: {GetCurrentScreen()}");
        if (GetCurrentScreen() == UIScreenManager.LobbySettingsScreenName)
        {
            Debug.Log("We were in the closed lobby, returning to lobby list");
            StartCoroutine(HandleLobbyClosedCoroutine(lobbyId));
        }
        else
        {
            Debug.Log($"Not returning to lobby list because we're on screen: {GetCurrentScreen()}");
        }
    }

    private IEnumerator HandleLobbyClosedCoroutine(string lobbyId)
    {
        yield return new WaitForSeconds(0.5f);
        ReturnToLobbyList();
    }

    public string GetCurrentScreen()
    {
        return _screenManager?.GetCurrentScreen() ?? "unknown";
    }

    public void ShowLobbyListAfterDisband()
    {
        StartCoroutine(ShowLobbyListAfterDisbandCoroutine());
    }

    private IEnumerator ShowLobbyListAfterDisbandCoroutine()
    {
        yield return new WaitForSeconds(1f);
        ShowScreen(UIScreenManager.LobbyListScreenName);
        UIManager.Instance?.OnLobbyListUpdated();
        LobbyDiscovery.Instance?.ForceDiscovery();
    }

    private void SetupClientModeUI()
    {
        var lobbySettingsScreen = _root.Q<VisualElement>("lobby_settings_screen");
        if (lobbySettingsScreen == null) return;

        // Скрываем элементы, которые недоступны клиентам
        var btnStartGame = lobbySettingsScreen.Q<Button>("btnStartGame");
        var btnDisbandLobby = lobbySettingsScreen.Q<Button>("btnDisbandLobby");
        var lobbyNameField = lobbySettingsScreen.Q<TextField>("lobbyNameField");
        var playerCountSlider = lobbySettingsScreen.Q<Slider>("playerCountSlider");

        if (btnStartGame != null) btnStartGame.style.display = DisplayStyle.None;
        if (btnDisbandLobby != null) btnDisbandLobby.style.display = DisplayStyle.None;
        if (lobbyNameField != null) lobbyNameField.SetEnabled(false);
        if (playerCountSlider != null) playerCountSlider.SetEnabled(false);

        Debug.Log("UI set to client mode - host controls disabled");
    }

    private void OnDestroy()
    {
        _inputManager?.Cleanup();
        _settings?.Cleanup();
    }
}
Файл: ./Scripts/MenuFeature/Network/LobbySystem.cs
﻿using Unity.Entities;
using Unity.NetCode;
using Unity.Collections;
using UnityEngine;

/// <summary>
/// Серверная система управления лобби (приём Join/Kick).
/// </summary>
[WorldSystemFilter(WorldSystemFilterFlags.ServerSimulation)]
[UpdateInGroup(typeof(SimulationSystemGroup))]
public partial struct LobbySystem : ISystem
{
    public void OnCreate(ref SystemState state)
    {
        state.RequireForUpdate<LobbyDataComponent>();
    }

    public void OnUpdate(ref SystemState state)
    {
        var ecb = new EntityCommandBuffer(Allocator.TempJob);
        var em = state.EntityManager;

        var lobbyEntity = SystemAPI.GetSingletonEntity<LobbyDataComponent>();
        var lobbyBuffer = em.GetBuffer<LobbyPlayerBuffer>(lobbyEntity);
        var lobbyData = em.GetComponentData<LobbyDataComponent>(lobbyEntity);

        // 🔹 Обработка команд JoinLobbyCommand (если остались старые — удаляем)
        foreach (var (joinCmd, req, entity) in SystemAPI
                     .Query<JoinLobbyCommand, ReceiveRpcCommandRequest>()
                     .WithEntityAccess())
        {
            var netId = em.GetComponentData<NetworkId>(req.SourceConnection).Value;
            var connId = (ulong)netId;

            if ((lobbyData.Password.Length == 0 || lobbyData.Password.Equals(joinCmd.Password))
                && lobbyBuffer.Length < lobbyData.MaxPlayers)
            {
                lobbyBuffer.Add(new LobbyPlayerBuffer
                {
                    PlayerName = joinCmd.PlayerName,
                    ConnectionId = connId
                });

                UnityEngine.Debug.Log($"[Server] Added player {joinCmd.PlayerName} (Conn={connId})");

                // Создаём сущность для SpawnPlayerCommand
                var spawn = ecb.CreateEntity();
                ecb.AddComponent(spawn, new SpawnPlayerCommand { ConnectionId = connId });
            }
            else
            {
                // Отказ — удаляем соединение
                var connQuery = em.CreateEntityQuery(ComponentType.ReadOnly<NetworkId>());
                using var entities = connQuery.ToEntityArray(Allocator.Temp);
                foreach (var e in entities)
                {
                    if ((ulong)em.GetComponentData<NetworkId>(e).Value == connId)
                    {
                        em.DestroyEntity(e);
                        break;
                    }
                }
            }

            ecb.DestroyEntity(entity);
        }

        // 🔹 Обработка KickPlayerCommand
        foreach (var (kickCmd, entity) in SystemAPI.Query<RefRO<KickPlayerCommand>>().WithEntityAccess())
        {
            for (int i = 0; i < lobbyBuffer.Length; i++)
            {
                if (lobbyBuffer[i].ConnectionId == kickCmd.ValueRO.ConnectionId)
                {
                    lobbyBuffer.RemoveAt(i);
                    break;
                }
            }

            var connQuery = em.CreateEntityQuery(ComponentType.ReadOnly<NetworkId>());
            using var entities = connQuery.ToEntityArray(Allocator.Temp);
            foreach (var e in entities)
            {
                if ((ulong)em.GetComponentData<NetworkId>(e).Value == kickCmd.ValueRO.ConnectionId)
                {
                    em.DestroyEntity(e);
                    break;
                }
            }

            ecb.DestroyEntity(entity);
        }

        ecb.Playback(em);
        ecb.Dispose();
    }
}

Файл: ./Scripts/MenuFeature/Network/ConnectionSystem.cs
﻿using Unity.Entities;
using Unity.NetCode;
using Unity.Collections;
using UnityEngine;

// Server-side system that reacts to new/disconnected connections
[WorldSystemFilter(WorldSystemFilterFlags.ServerSimulation)]
[UpdateInGroup(typeof(SimulationSystemGroup))]
public partial struct ConnectionSystem : ISystem
{
    ComponentLookup<NetworkId> _netIdLookup;

    public void OnCreate(ref SystemState state)
    {
        _netIdLookup = state.GetComponentLookup<NetworkId>(true);
        state.RequireForUpdate<NetworkStreamConnection>();
    }

    public void OnUpdate(ref SystemState state)
    {
        var em = state.EntityManager;

        // New connections: entities that have NetworkStreamConnection but not yet InGame
        using var connectedEntities = em.CreateEntityQuery(
            ComponentType.ReadOnly<NetworkId>(),
            ComponentType.ReadOnly<NetworkStreamConnection>(),
            ComponentType.Exclude<NetworkStreamInGame>()
        ).ToEntityArray(Allocator.Temp);

        foreach (var entity in connectedEntities)
        {
            var netId = em.GetComponentData<NetworkId>(entity).Value;
            var cmd = em.CreateEntity();
            em.AddComponentData(cmd, new SpawnPlayerCommand { ConnectionId = (ulong)netId });
            em.AddComponent<NetworkStreamInGame>(entity); // mark as in game

            UIManager.Instance?.OnPlayerJoined(netId, "New Player");
        }

        // Disconnected connections
        using var disconnectedEntities = em.CreateEntityQuery(
            ComponentType.ReadOnly<NetworkId>(),
            ComponentType.Exclude<NetworkStreamConnection>()
        ).ToEntityArray(Allocator.Temp);

        foreach (var entity in disconnectedEntities)
        {
            if (em.HasComponent<NetworkId>(entity))
            {
                int netId = em.GetComponentData<NetworkId>(entity).Value;
                UIManager.Instance?.OnPlayerLeft(netId);
            }
        }
    }
}

Файл: ./Scripts/MenuFeature/Network/LobbyDiscovery.cs
﻿using UnityEngine;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Collections.Generic;
using System;
using Unity.NetCode;
using System.Collections;

/// <summary>
/// Локальное LAN-обнаружение лобби через UDP Broadcast.
/// </summary>
public class LobbyDiscovery : MonoBehaviour
{
    public static LobbyDiscovery Instance { get; private set; }

    public int broadcastPort = 8888;
    public int gamePort = 7777;
    public float broadcastInterval = 2f;

    private UdpClient udpClient;
    private IPEndPoint broadcastEndPoint;
    private Thread listenThread;
    public Action<List<LobbyInfo>> OnLobbiesUpdated;
    public List<LobbyInfo> DiscoveredLobbies = new();
    public event Action<string> OnLobbyClosed;

    private string uniqueId;
    private bool isInitialized = false;
    private bool isHost = false;
    private LobbyInfo currentLobbyInfo;
    private bool _needsLobbyUpdate = false;

    private Dictionary<string, float> _lobbyLastSeen = new Dictionary<string, float>();
    private float _cleanupInterval = 5f; // проверяем каждые 5 секунд
    private float _lobbyTimeout = 10f; // лобби считается устаревшим после 10 секунд

    public string UniqueID => uniqueId;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
        uniqueId = Guid.NewGuid().ToString().Substring(0, 8);

        // УВЕЛИЧЬТЕ ТАЙМАУТ ДЛЯ ТЕСТИРОВАНИЯ
        _lobbyTimeout = 30f; // 30 секунд вместо 10
        _cleanupInterval = 10f; // Проверяем каждые 10 секунд вместо 5
    }

    private IEnumerator CleanupExpiredLobbies()
    {
        while (true)
        {
            yield return new WaitForSeconds(_cleanupInterval);

            // ФИКС: Вся логика в главном потоке
            UnityMainThreadDispatcher.Instance.Enqueue(() =>
            {
                lock (DiscoveredLobbies)
                {
                    Debug.Log($"CleanupExpiredLobbies: Starting cleanup, current lobbies: {DiscoveredLobbies.Count}");

                    var currentTime = (float)DateTime.Now.Subtract(DateTime.Today).TotalSeconds;
                    var lobbiesToRemove = new List<string>();

                    foreach (var lobbyId in _lobbyLastSeen.Keys)
                    {
                        var lastSeen = _lobbyLastSeen[lobbyId];
                        var timeSinceLastSeen = currentTime - lastSeen;
                        Debug.Log($"CleanupExpiredLobbies: Lobby {lobbyId} - last seen: {lastSeen}, time since: {timeSinceLastSeen}, timeout: {_lobbyTimeout}");

                        if (timeSinceLastSeen > _lobbyTimeout)
                        {
                            lobbiesToRemove.Add(lobbyId);
                            Debug.Log($"CleanupExpiredLobbies: Marking lobby {lobbyId} for removal (timeout)");
                        }
                    }

                    foreach (var lobbyId in lobbiesToRemove)
                    {
                        DiscoveredLobbies.RemoveAll(l => l.uniqueId == lobbyId);
                        _lobbyLastSeen.Remove(lobbyId);
                        Debug.Log($"CleanupExpiredLobbies: Removed expired lobby: {lobbyId}");
                    }

                    if (lobbiesToRemove.Count > 0)
                    {
                        _needsLobbyUpdate = true;
                        Debug.Log($"CleanupExpiredLobbies: Removed {lobbiesToRemove.Count} lobbies, scheduling UI update");
                    }

                    Debug.Log($"CleanupExpiredLobbies: Cleanup completed, lobbies remaining: {DiscoveredLobbies.Count}");
                }
            });
        }
    }

    private void Start() => StartCoroutine(StartDiscovery());

    private void Update()
    {
        if (_needsLobbyUpdate)
        {
            _needsLobbyUpdate = false;
            Debug.Log($"LobbyDiscovery: Updating UI with {DiscoveredLobbies.Count} lobbies");
            OnLobbiesUpdated?.Invoke(new List<LobbyInfo>(DiscoveredLobbies));
        }
    }

    private IEnumerator StartDiscovery()
    {
        yield return new WaitForSeconds(1f);
        if (isInitialized) yield break;

        try
        {
            udpClient = new UdpClient();
            udpClient.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            udpClient.Client.Bind(new IPEndPoint(IPAddress.Any, broadcastPort));
            udpClient.EnableBroadcast = true;

            broadcastEndPoint = new IPEndPoint(IPAddress.Broadcast, broadcastPort);

            Debug.Log($"LobbyDiscovery: Bound to port {broadcastPort}, broadcasting to {broadcastEndPoint}");

            listenThread = new Thread(ListenForBroadcasts) { IsBackground = true };
            listenThread.Start();
            StartCoroutine(SendDiscoveryRequest());
            StartCoroutine(CleanupExpiredLobbies());

            isInitialized = true;
            Debug.Log($"LobbyDiscovery initialized (port {broadcastPort}, ID={uniqueId})");
        }
        catch (Exception e)
        {
            Debug.LogError($"LobbyDiscovery init failed: {e.Message}");
        }
    }

    public void ForceDiscovery()
    {
        DebugNetworkInfo();

        if (!isHost && udpClient != null)
        {
            try
            {
                udpClient.Send(Encoding.UTF8.GetBytes("DISCOVER"), 7, broadcastEndPoint);
                Debug.Log("Forced DISCOVER request sent");
            }
            catch (Exception e)
            {
                Debug.LogError($"Forced discovery failed: {e.Message}");
            }
        }
    }

    private void ListenForBroadcasts()
    {
        var remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
        Debug.Log("LobbyDiscovery: Starting to listen for broadcasts...");

        while (true)
        {
            try
            {
                var data = udpClient.Receive(ref remoteEndPoint);
                var msg = Encoding.UTF8.GetString(data);
                Debug.Log($"Received raw message from {remoteEndPoint}: {msg}");

                if (msg.StartsWith("LOBBY:"))
                {
                    Debug.Log("Processing LOBBY message...");
                    var json = msg.Substring(6);
                    Debug.Log($"LOBBY JSON: {json}");

                    var info = JsonUtility.FromJson<LobbyInfo>(json);
                    Debug.Log($"Parsed lobby: {info.name}, uniqueId: {info.uniqueId}, myId: {uniqueId}");

                    if (info.uniqueId == uniqueId)
                    {
                        Debug.Log($"Ignoring own lobby: {info.uniqueId}");
                        continue;
                    }

                    info.ip = remoteEndPoint.Address.ToString();
                    if (info.port == 0) info.port = gamePort;

                    Debug.Log($"Discovered lobby: {info.name} from {info.ip}:{info.port}");

                    // КРИТИЧЕСКИЙ ФИКС: ВЫЗЫВАЕМ UpdateLobbyList
                    UpdateLobbyList(info);
                    _needsLobbyUpdate = true;
                    Debug.Log($"LobbyDiscovery: UpdateLobbyList called and UI update scheduled for {info.name}");
                }
                else if (msg.StartsWith("LOBBY_CLOSE:"))
                {
                    string closedLobbyId = msg.Substring(12);
                    Debug.Log($"Received lobby close: {closedLobbyId}");

                    // ФИКС: Используем UnityMainThreadDispatcher для вызова событий
                    UnityMainThreadDispatcher.Instance.Enqueue(() =>
                    {
                        // Вызываем событие перед удалением
                        OnLobbyClosed?.Invoke(closedLobbyId);

                        // Удаляем лобби из списка
                        RemoveLobbyById(closedLobbyId);
                    });
                }
                else if (msg == "DISCOVER" && isHost)
                {
                    Debug.Log("Received DISCOVER request, broadcasting lobby");
                    BroadcastLobby(currentLobbyInfo);
                }
                else
                {
                    Debug.Log($"Unknown message type: {msg}");
                }
            }
            catch (Exception e)
            {
                if (e is ThreadAbortException or ObjectDisposedException)
                    break;
                Debug.LogWarning($"Listen error: {e.Message}");
            }
        }
    }


    private void RemoveLobbyById(string lobbyId)
    {
        bool wasRemoved = false;
        lock (DiscoveredLobbies)
        {
            int removed = DiscoveredLobbies.RemoveAll(l => l.uniqueId == lobbyId);
            if (removed > 0)
            {
                _lobbyLastSeen.Remove(lobbyId);
                wasRemoved = true;
                Debug.Log($"Removed lobby from discovery: {lobbyId}");
            }
        }

        // ФИКС: Обновляем UI через главный поток
        if (wasRemoved)
        {
            UnityMainThreadDispatcher.Instance.Enqueue(() =>
            {
                _needsLobbyUpdate = true;
                Debug.Log($"Lobby {lobbyId} removed, scheduling UI update");
            });
        }
    }

    private void UpdateLobbyList(LobbyInfo newLobby)
    {
        Debug.Log($"=== UpdateLobbyList START ===");

        try
        {
            lock (DiscoveredLobbies)
            {
                Debug.Log($"Adding lobby: {newLobby.name} (ID: {newLobby.uniqueId})");

                int existingIndex = DiscoveredLobbies.FindIndex(l => l.uniqueId == newLobby.uniqueId);
                if (existingIndex >= 0)
                {
                    DiscoveredLobbies[existingIndex] = newLobby;
                    Debug.Log($"Updated existing lobby at index {existingIndex}");
                }
                else
                {
                    DiscoveredLobbies.Add(newLobby);
                    Debug.Log($"Added new lobby. Total count: {DiscoveredLobbies.Count}");
                }

                // ФИКС: Используем DateTime для времени в фоновом потоке
                _lobbyLastSeen[newLobby.uniqueId] = (float)DateTime.Now.Subtract(DateTime.Today).TotalSeconds;
                Debug.Log($"Set last seen for lobby {newLobby.uniqueId}");
            }

            // Только обновление UI через главный поток
            UnityMainThreadDispatcher.Instance.Enqueue(() =>
            {
                _needsLobbyUpdate = true;
                Debug.Log($"UI update scheduled");
            });
        }
        catch (Exception e)
        {
            Debug.LogError($"UpdateLobbyList ERROR: {e.Message}\n{e.StackTrace}");
        }

        Debug.Log($"=== UpdateLobbyList END ===");
    }

    private IEnumerator SendDiscoveryRequest()
    {
        while (true)
        {
            if (udpClient != null && !isHost)
            {
                try
                {
                    udpClient.Send(Encoding.UTF8.GetBytes("DISCOVER"), 7, broadcastEndPoint);
                    Debug.Log($"Sent DISCOVER request to {broadcastEndPoint}");
                }
                catch (Exception e)
                {
                    Debug.LogError($"Failed to send DISCOVER: {e.Message}");
                }
            }
            yield return new WaitForSeconds(3f);
        }
    }

    

    public void StartHosting(LobbyInfo info)
    {
        isHost = true;
        currentLobbyInfo = info;
        currentLobbyInfo.uniqueId = uniqueId;
        currentLobbyInfo.port = gamePort;

        Debug.Log($"Started hosting lobby: {info.name} on port {gamePort}");
        BroadcastLobby(currentLobbyInfo);
        StartCoroutine(HostBroadcastLoop());
    }

    public void StopHosting() => isHost = false;

    private IEnumerator HostBroadcastLoop()
    {
        while (isHost)
        {
            BroadcastLobby(currentLobbyInfo);
            yield return new WaitForSeconds(broadcastInterval);
        }
    }

    public void BroadcastLobby(LobbyInfo info)
    {
        if (udpClient == null || !isHost) return;
        try
        {
            string message = "LOBBY:" + JsonUtility.ToJson(info);
            byte[] data = Encoding.UTF8.GetBytes(message);
            udpClient.Send(data, data.Length, broadcastEndPoint);
            Debug.Log($"Broadcasted lobby to {broadcastEndPoint}: {info.name} at {info.ip}:{info.port}");
        }
        catch (Exception e)
        {
            Debug.LogError($"Broadcast failed: {e.Message}");
        }
    }

    public void StopHostingAndNotify()
    {
        if (!isHost) return;

        // ОТПРАВЛЯЕМ СООБЩЕНИЕ О ЗАКРЫТИИ ЛОББИ
        try
        {
            string closeMessage = "LOBBY_CLOSE:" + uniqueId;
            byte[] data = Encoding.UTF8.GetBytes(closeMessage);
            udpClient.Send(data, data.Length, broadcastEndPoint);
            Debug.Log($"Sent lobby close notification: {uniqueId}");
        }
        catch (Exception e)
        {
            Debug.LogWarning($"Failed to send lobby close notification: {e.Message}");
        }

        // ОСТАНАВЛИВАЕМ ХОСТИНГ
        isHost = false;
    }

    public void DebugNetworkInfo()
    {
        Debug.Log($"LobbyDiscovery Debug Info:");
        Debug.Log($"- Initialized: {isInitialized}");
        Debug.Log($"- Is Host: {isHost}");
        Debug.Log($"- My ID: {uniqueId}");
        Debug.Log($"- Discovered Lobbies: {DiscoveredLobbies.Count}");
        Debug.Log($"- Broadcast Port: {broadcastPort}");
        Debug.Log($"- Game Port: {gamePort}");

        foreach (var lobby in DiscoveredLobbies)
        {
            Debug.Log($"  - Lobby: {lobby.name} ({lobby.ip}:{lobby.port})");
        }
    }

    private void OnDestroy()
    {
        if (listenThread != null && listenThread.IsAlive)
            listenThread.Abort();

        udpClient?.Close();
        udpClient = null;
        if (Instance == this) Instance = null;
    }

    public List<LobbyInfo> GetDiscoveredLobbies()
    {
        List<LobbyInfo> result;
        lock (DiscoveredLobbies)
        {
            result = new List<LobbyInfo>(DiscoveredLobbies);
            Debug.Log($"=== GetDiscoveredLobbies ===");
            Debug.Log($"Returning {result.Count} lobbies");

            foreach (var lobby in result)
            {
                Debug.Log($"  - Returning: {lobby.name} (ID: {lobby.uniqueId})");
            }
            Debug.Log($"=== End GetDiscoveredLobbies ===");
        }
        return result;
    }

    public void ClearLobbies()
    {
        lock (DiscoveredLobbies)
        {
            DiscoveredLobbies.Clear();
            _needsLobbyUpdate = true;
        }
    }
}
Файл: ./Scripts/MenuFeature/Network/PingSystem.cs
﻿using Unity.Entities;
using Unity.NetCode;

[WorldSystemFilter(WorldSystemFilterFlags.ClientSimulation | WorldSystemFilterFlags.ServerSimulation)]
[UpdateInGroup(typeof(SimulationSystemGroup))]
public partial struct PingSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        // Используем NetworkSnapshotAck.EstimatedRTT (в секундах) и переводим в миллисекунды.
        // NetworkSnapshotAck доступен как singleton в NetCode; на клиенте он хранит RTT оценки.
        if (state.WorldUnmanaged.IsClient())
        {
            if (SystemAPI.HasSingleton<NetworkSnapshotAck>())
            {
                var ack = SystemAPI.GetSingleton<NetworkSnapshotAck>();
                int ms = (int)(ack.EstimatedRTT * 1000f);
                foreach (var player in SystemAPI.Query<RefRW<PlayerComponent>>())
                {
                    player.ValueRW.Ping = ms;
                }
            }
            else
            {
                foreach (var player in SystemAPI.Query<RefRW<PlayerComponent>>())
                {
                    player.ValueRW.Ping = 0;
                }
            }
        }
        else if (state.WorldUnmanaged.IsServer())
        {
            // Серверная оценка RTT на клиентах требует доступа к транспортной статистике.
            // Для простоты здесь ставим 0 (или можно интегрировать с конкретным транспортом).
            foreach (var player in SystemAPI.Query<RefRW<PlayerComponent>>())
            {
                player.ValueRW.Ping = 0;
            }
        }
    }
}

Файл: ./Scripts/MenuFeature/Network/JoinLobbySystem.cs
﻿using Unity.Entities;
using Unity.NetCode;
using Unity.Collections;
using UnityEngine;

[WorldSystemFilter(WorldSystemFilterFlags.ServerSimulation)]
public partial struct JoinLobbySystem : ISystem
{
    public void OnCreate(ref SystemState state)
    {
        state.RequireForUpdate<ReceiveRpcCommandRequest>();
    }

    public void OnUpdate(ref SystemState state)
    {
        var ecb = new EntityCommandBuffer(Allocator.Temp);
        var em = state.EntityManager;

        foreach (var (cmd, req, entity) in SystemAPI
                     .Query<JoinLobbyCommand, ReceiveRpcCommandRequest>()
                     .WithEntityAccess())
        {
            UnityEngine.Debug.Log($"[Server] JoinLobby RPC: {cmd.PlayerName}");

            var query = em.CreateEntityQuery(typeof(LobbyDataComponent), typeof(LobbyPlayerBuffer));
            if (query.IsEmptyIgnoreFilter)
            {
                ecb.DestroyEntity(entity);
                continue;
            }

            var lobbyEntity = query.GetSingletonEntity();
            var lobbyData = em.GetComponentData<LobbyDataComponent>(lobbyEntity);
            var buffer = em.GetBuffer<LobbyPlayerBuffer>(lobbyEntity);

            // проверяем пароль и лимит
            if ((lobbyData.Password.Length == 0 || lobbyData.Password.Equals(cmd.Password))
                && buffer.Length < lobbyData.MaxPlayers)
            {
                var connId = (ulong)em.GetComponentData<NetworkId>(req.SourceConnection).Value;
                buffer.Add(new LobbyPlayerBuffer
                {
                    PlayerName = cmd.PlayerName,
                    ConnectionId = connId
                });

                UnityEngine.Debug.Log($"[Server] Added player {cmd.PlayerName} (Conn={connId})");
            }
            else
            {
                UnityEngine.Debug.LogWarning("[Server] JoinLobby rejected (password or full)");
            }

            ecb.DestroyEntity(entity);
        }

        ecb.Playback(state.EntityManager);
        ecb.Dispose();
    }
}

Файл: ./Scripts/MenuFeature/Network/LobbyManager.cs
﻿using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.SceneManagement;
using Unity.Entities;
using Unity.NetCode;
using System.Collections;
using System.Collections.Generic;
using Unity.Collections;
using System.Net;
using System.Net.Sockets;
using System;
using System.Threading;

/// <summary>
/// Управляет локальным лобби: создает серверный мир, запускает discovery broadcast через LobbyDiscovery,
/// отслеживает текущее число игроков и — при достижении maxPlayers — помечает лобби скрытым и стартует игру.
/// </summary>
public class LobbyManager : MonoBehaviour
{
    private LobbyDiscovery _discovery;
    private LobbyData? _currentLobby;
    private LobbyInfo? _currentLobbyInfo;
    private Dictionary<ulong, PlayerData> _players = new();
    private bool _gameStarted = false;
    private Coroutine _lobbyMonitorCoroutine;

    private void Start()
    {
        _discovery = LobbyDiscovery.Instance;
        if (_discovery == null)
        {
            _discovery = gameObject.AddComponent<LobbyDiscovery>();
        }

        // ФИКС: Убедитесь, что подписка происходит в главном потоке
        _discovery.OnLobbiesUpdated += OnLobbiesUpdated;

        if (LobbyDiscovery.Instance != null)
        {
            LobbyDiscovery.Instance.OnLobbyClosed += OnLobbyClosed;
        }
    }

    private void OnLobbyClosed(string lobbyId)
    {
        Debug.Log($"LobbyManager: Lobby {lobbyId} was closed by host");

        // ФИКС: Упрощенная и надежная логика определения нужно ли возвращаться к списку
        UnityMainThreadDispatcher.Instance.Enqueue(() =>
        {
            StartCoroutine(HandleLobbyClosedCoroutine(lobbyId));
        });
    }



    private IEnumerator HandleLobbyClosedCoroutine(string lobbyId)
    {
        yield return new WaitForSeconds(0.5f); // Даем время на синхронизацию

        // Проверяем, находимся ли мы в клиентском режиме И в настройках лобби
        var clientWorld = GetClientWorld();
        bool isClient = clientWorld != null && clientWorld.IsCreated && clientWorld.IsClient();
        bool isInLobbySettings = UIManager.Instance?.GetCurrentScreen() == "lobby_settings_screen";

        Debug.Log($"HandleLobbyClosed: isClient={isClient}, isInLobbySettings={isInLobbySettings}, closedLobbyId={lobbyId}");

        // ФИКС: Возвращаемся только если мы клиент И находимся в настройках лобби
        if (isClient && isInLobbySettings)
        {
            Debug.Log("We are a client in lobby settings and host closed the lobby, returning to lobby list");

            // Закрываем клиентское соединение
            ShutdownClientWorld();

            // Очищаем сохраненные данные о подключении
            PlayerPrefs.DeleteKey("JoiningLobbyIP");
            PlayerPrefs.DeleteKey("JoiningLobbyPort");
            PlayerPrefs.Save();

            // Возвращаемся к списку лобби
            var mainMenuController = FindObjectOfType<MainMenuController>();
            if (mainMenuController != null)
            {
                mainMenuController.ReturnToLobbyList();
            }
            else
            {
                UIManager.Instance?.ReturnToLobbyList();
            }
        }
        else
        {
            Debug.Log($"HandleLobbyClosed: Not affected - isClient={isClient}, isInLobbySettings={isInLobbySettings}");
        }
    }


    private void ShutdownClientWorld()
    {
        var clientWorld = GetClientWorld();
        if (clientWorld != null && clientWorld.IsCreated)
        {
            try
            {
                clientWorld.Dispose();
                Debug.Log("Client world disposed");
            }
            catch (Exception e)
            {
                Debug.LogWarning($"Error disposing client world: {e.Message}");
            }
        }
    }



    private World GetServerWorld()
    {
        foreach (var w in World.All)
        {
            if (w.IsCreated && w.IsServer())
                return w;
        }
        return null;
    }

    private World GetClientWorld()
    {
        foreach (var w in World.All)
        {
            if (w.IsCreated && w.IsClient())
                return w;
        }
        return null;
    }

    public void CreateLobby(LobbyData data, PlayerData hostData)
    {
        _currentLobby = data;

        if (GetServerWorld() == null)
            CreateServer();

        var serverWorld = GetServerWorld();
        if (serverWorld == null)
        {
            Debug.LogError("Failed to create server world!");
            return;
        }

        var em = serverWorld.EntityManager;

        var oldQuery = em.CreateEntityQuery(typeof(LobbyDataComponent));
        if (!oldQuery.IsEmptyIgnoreFilter)
            em.DestroyEntity(oldQuery.GetSingletonEntity());

        var lobbyEntity = em.CreateEntity();
        em.AddComponentData(lobbyEntity, new LobbyDataComponent
        {
            Name = new FixedString128Bytes(data.name),
            Password = new FixedString64Bytes(data.password),
            MaxPlayers = data.maxPlayers,
            IsOpen = data.isOpen
        });

        var buffer = em.AddBuffer<LobbyPlayerBuffer>(lobbyEntity);
        _players.Clear();
        _players[0] = hostData;
        buffer.Add(new LobbyPlayerBuffer
        {
            PlayerName = new FixedString128Bytes(hostData.name),
            ConnectionId = 0
        });

        _currentLobbyInfo = new LobbyInfo
        {
            name = data.name,
            currentPlayers = 1,
            maxPlayers = data.maxPlayers,
            isOpen = data.isOpen,
            password = data.password,
            ip = GetLocalIPAddress(),
            port = _discovery.gamePort,
            uniqueId = _discovery.UniqueID
        };

        _discovery.StartHosting(_currentLobbyInfo.Value);

        if (_lobbyMonitorCoroutine != null) StopCoroutine(_lobbyMonitorCoroutine);
        _lobbyMonitorCoroutine = StartCoroutine(LobbyBroadcastAndMonitorLoop());

        UIManager.Instance.OnLobbyListUpdated();
        UIManager.Instance.OnLobbyCreated();
        UIManager.Instance.OnPlayersUpdated();

        Debug.Log($"Lobby created: {data.name}, broadcasting on port {_discovery.broadcastPort}");
    }

    private IEnumerator LobbyBroadcastAndMonitorLoop()
    {
        // Проверяем, что лобби существует
        if (!_currentLobbyInfo.HasValue) yield break;

        // Периодически обновляем поле currentPlayers и шлём broadcast
        while (!_gameStarted)
        {
            int count = GetPlayerCount();
            var currentInfo = _currentLobbyInfo.Value;
            currentInfo.currentPlayers = Mathf.Max(1, count); // >=1 (хост)
            // Если стали меньше max — оставляем isOpen как есть (обычно true), если достигли — закрываем
            if (currentInfo.currentPlayers >= currentInfo.maxPlayers)
            {
                // Пометим как закрытое — чтобы клиенты не пытались зайти
                currentInfo.isOpen = false;
                _currentLobbyInfo = currentInfo;
                _discovery.BroadcastLobby(currentInfo); // одноразовое обновление со статусом закрыто
                Debug.Log("Lobby full — broadcasting hide/closed and starting game.");
                // Небольшая задержка, чтобы клиенты успели получить сообщение
                yield return new WaitForSeconds(0.5f);
                StartGame(); // автоматически стартуем игру
                yield break;
            }
            else
            {
                // Обычная регулярная рассылка актуального состояния (имя/кол-во/порт)
                if (_currentLobby.HasValue)
                {
                    currentInfo.isOpen = _currentLobby.Value.isOpen;
                }
                _currentLobbyInfo = currentInfo;
                _discovery.BroadcastLobby(currentInfo);
            }

            yield return new WaitForSeconds(1.0f);
        }
    }

    private void CreateServer()
    {
#if UNITY_EDITOR
        // В редакторе создаем и сервер и клиент
        if (World.All.Count == 0)
        {
            var server = ClientServerBootstrap.CreateServerWorld("ServerWorld");
            var client = ClientServerBootstrap.CreateClientWorld("ClientWorld");
        }
#endif
    }

    private void CreateClient()
    {
        if (GetClientWorld() == null)
        {
            ClientServerBootstrap.CreateClientWorld("ClientWorld");
        }
    }

    private string GetLocalIPAddress()
    {
        try
        {
            var host = Dns.GetHostEntry(Dns.GetHostName());
            foreach (var ip in host.AddressList)
            {
                if (ip.AddressFamily == AddressFamily.InterNetwork)
                {
                    Debug.Log($"Found local IP: {ip}");
                    return ip.ToString();
                }
            }

            // Если не нашли подходящий IP, используем локальный
            Debug.LogWarning("No suitable local IP found, using 127.0.0.1");
            return "127.0.0.1";
        }
        catch (Exception ex)
        {
            Debug.LogError($"Error getting local IP: {ex.Message}");
            return "127.0.0.1";
        }
    }

    public void JoinLobby(LobbyInfo lobbyInfo, string playerName, string password = "")
    {
        Debug.Log($"Joining lobby: {lobbyInfo.name} at {lobbyInfo.ip}:{lobbyInfo.port}");

        PlayerPrefs.SetString("JoiningLobbyIP", lobbyInfo.ip);
        PlayerPrefs.SetInt("JoiningLobbyPort", lobbyInfo.port);
        PlayerPrefs.SetString("JoiningPlayerName", playerName);
        PlayerPrefs.Save();

        var mainMenuController = FindObjectOfType<MainMenuController>();
        if (mainMenuController != null)
            mainMenuController.OnJoinedAsClient();
        else
            SceneManager.LoadScene("LobbyScene");

        // получаем строковое название оружия по индексу
        string weaponName = GetWeaponNameFromIndex(SettingsManager.Instance.CurrentSettings.defaultWeaponIndex);

        // отправляем JoinLobbyCommand
        var clientWorld = GetClientWorld();
        if (clientWorld != null)
        {
            var em = clientWorld.EntityManager;
            var req = em.CreateEntity();
            em.AddComponentData(req, new JoinLobbyCommand
            {
                PlayerName = new FixedString128Bytes(playerName),
                Weapon = new FixedString64Bytes(weaponName),
                Password = new FixedString64Bytes(password ?? "")
            });
            em.AddComponentData(req, new SendRpcCommandRequest { TargetConnection = Entity.Null });
        }

        UIManager.Instance.OnLobbyListUpdated();
    }

    private string GetWeaponNameFromIndex(int index)
    {
        switch (index)
        {
            case 0: return "Termit\"Flamethrower\"";
            case 1: return "Titan \"Autocannon\"";
            case 2: return "Volt \"Stun Gun\"";
            case 3: return "Vikhr \"Twin Machine Gun\"";
            default: return $"Weapon{index}";
        }
    }

    private IEnumerator LoadLobbySceneWithDelay()
    {
        yield return new WaitForSeconds(1f);

        try
        {
            if (Application.CanStreamedLevelBeLoaded("LobbyScene"))
            {
                SceneManager.LoadScene("LobbyScene");
            }
            else if (Application.CanStreamedLevelBeLoaded("GameCoreScene"))
            {
                SceneManager.LoadScene("GameCoreScene");
            }
            else
            {
                SceneManager.LoadScene(0);
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"Failed to load scene: {e.Message}");
            SceneManager.LoadScene("MainMenu");
        }
    }

    public void KickPlayer(ulong connectionId)
    {
        var serverWorld = GetServerWorld();
        if (serverWorld == null) return;
        var em = serverWorld.EntityManager;
        var query = em.CreateEntityQuery(ComponentType.ReadOnly<NetworkId>());
        using var entities = query.ToEntityArray(Unity.Collections.Allocator.Temp);
        foreach (var e in entities)
        {
            if (em.GetComponentData<NetworkId>(e).Value == (int)connectionId)
            {
                em.DestroyEntity(e);
                break;
            }
        }
        _players.Remove(connectionId);
        UIManager.Instance.OnPlayerLeft((int)connectionId);
    }

    private bool _isDisbanding = false; // Добавляем флаг

    public void DisbandLobby()
    {
        if (_isDisbanding)
        {
            Debug.LogWarning("LobbyManager: DisbandLobby already in progress, ignoring duplicate call");
            return;
        }

        _isDisbanding = true;
        Debug.Log("LobbyManager: Starting lobby disband process...");

        try
        {
            // Останавливаем корутины
            if (_lobbyMonitorCoroutine != null)
            {
                Debug.Log("Stopping lobby monitor coroutine...");
                StopCoroutine(_lobbyMonitorCoroutine);
                _lobbyMonitorCoroutine = null;
            }

            // ФИКС: Сначала уведомляем о закрытии
            if (LobbyDiscovery.Instance != null)
            {
                Debug.Log("Sending lobby close notification...");
                LobbyDiscovery.Instance.StopHostingAndNotify();
            }

            // Очищаем данные лобби
            Debug.Log("Clearing lobby data...");
            _players.Clear();
            _gameStarted = false;
            _currentLobby = null;
            _currentLobbyInfo = null;

            // Уничтожаем NetCode миры
            Debug.Log("Shutting down NetCode worlds...");
            ShutdownAllNetCodeWorlds();

            // Останавливаем хостинг в discovery
            if (_discovery != null)
            {
                Debug.Log("Stopping discovery hosting...");
                _discovery.StopHosting();
            }

            // Возвращаем в главное меню
            Debug.Log("Returning to main menu...");
            StartCoroutine(ReturnToMainMenuWithDelay());

            Debug.Log("Lobby disbanded successfully");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error during lobby disband: {e.Message}\n{e.StackTrace}");
            // Все равно пытаемся вернуться в главное меню
            StartCoroutine(ReturnToMainMenuWithDelay());
        }
        finally
        {
            _isDisbanding = false;
        }
    }

    private IEnumerator ReturnToMainMenuWithDelay()
    {
        yield return new WaitForSeconds(0.5f); // Даем время на очистку сетевых соединений

        if (UIManager.Instance != null)
        {
            UIManager.Instance.LeaveGame();
        }
        else
        {
            SceneManager.LoadScene("MainMenu");
        }
    }

    public void StartGame()
    {
        if (_gameStarted) return;
        _gameStarted = true;
        // Остановим broadcasting — discovery сам прекратит, когда мы вызовем StopHosting
        _discovery.StopHosting();

        var serverWorld = GetServerWorld();
        if (serverWorld == null) return;
        var em = serverWorld.EntityManager;
        var startEntity = em.CreateEntity();
        em.AddComponentData(startEntity, new StartGameCommand { });

        StartCoroutine(LoadGameSceneWithDelay());
    }

    private IEnumerator LoadGameSceneWithDelay()
    {
        yield return new WaitForSeconds(1f);

        try
        {
            if (Application.CanStreamedLevelBeLoaded("GameCoreScene"))
            {
                SceneManager.LoadScene("GameCoreScene");
            }
            else
            {
                Debug.LogWarning("GameCoreScene not found, loading first available scene");
                SceneManager.LoadScene(0);
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"Failed to load game scene: {e.Message}");
            SceneManager.LoadScene("MainMenu");
        }
    }

    private int GetPlayerCount()
    {
        var serverWorld = GetServerWorld();
        if (serverWorld == null) return 1; // хотя бы хост
        var em = serverWorld.EntityManager;
        var query = em.CreateEntityQuery(typeof(LobbyPlayerBuffer));
        if (query.IsEmptyIgnoreFilter) return 1;
        return em.GetBuffer<LobbyPlayerBuffer>(query.GetSingletonEntity()).Length;
    }

    public void PopulateLobbyList(ScrollView scroll)
    {
        scroll.Clear();
        var lobbies = GetDiscoveredLobbies();
        if (lobbies == null || lobbies.Count == 0)
        {
            var noLobbies = new Label("No lobbies found");
            noLobbies.AddToClassList("no-lobbies-label");
            scroll.Add(noLobbies);
            return;
        }

        foreach (var lobby in lobbies)
        {
            CreateLobbyItem(scroll, lobby);
        }
    }

    public List<LobbyInfo> GetDiscoveredLobbies()
    {
        if (_discovery != null)
        {
            var lobbies = _discovery.GetDiscoveredLobbies();
            Debug.Log($"GetDiscoveredLobbies: returning {lobbies.Count} lobbies");
            foreach (var lobby in lobbies)
            {
                Debug.Log($" - {lobby.name} ({lobby.ip}:{lobby.port}), Open: {lobby.isOpen}");
            }
            return lobbies;
        }
        Debug.LogWarning("GetDiscoveredLobbies: _discovery is null");
        return new List<LobbyInfo>();
    }

    public void PopulatePlayerList(ScrollView scroll)
    {
        scroll.Clear();
        var serverWorld = GetServerWorld();
        if (serverWorld == null) return;
        var em = serverWorld.EntityManager;
        var query = em.CreateEntityQuery(ComponentType.ReadOnly<LobbyPlayerBuffer>());
        if (query.IsEmptyIgnoreFilter) return;
        var buffer = em.GetBuffer<LobbyPlayerBuffer>(query.GetSingletonEntity());
        for (int i = 0; i < buffer.Length; i++)
        {
            var p = buffer[i];
            CreatePlayerItem(scroll, p.ConnectionId, p.PlayerName.ToString());
        }
    }

    private VisualElement CreateLobbyItem(ScrollView scroll, LobbyInfo info)
    {
        var item = new VisualElement();
        item.AddToClassList("lobby-item");

        var nameLabel = new Label(info.name);
        nameLabel.AddToClassList("lobby-name");

        var playersLabel = new Label($"{info.currentPlayers}/{info.maxPlayers}");
        playersLabel.AddToClassList("lobby-players");

        var typeLabel = new Label(info.isOpen ? "Open" : "Password");
        typeLabel.AddToClassList("lobby-type");

        var joinBtn = new Button(() => {
            if (info.isOpen || string.IsNullOrEmpty(info.password))
            {
                JoinLobby(info, SettingsManager.Instance.CurrentSettings.playerName, info.password);
            }
            else
            {
                ShowPasswordPrompt(info);
            }
        })
        {
            text = "Join"
        };
        joinBtn.AddToClassList("join-button");

        item.Add(nameLabel);
        item.Add(playersLabel);
        item.Add(typeLabel);
        item.Add(joinBtn);

        scroll.Add(item);
        return item;
    }

    public void ShowPasswordPrompt(LobbyInfo lobbyInfo)
    {
        string password = "";

#if UNITY_EDITOR
        // В редакторе используем системный диалог — оставляем упрощение
#else
        Debug.Log("Password protected lobby - using temporary password '123'");
        password = "123";
#endif

        if (!string.IsNullOrEmpty(password))
        {
            var mainMenuController = FindObjectOfType<MainMenuController>();
            if (mainMenuController != null)
            {
                mainMenuController.OnJoinedAsClient();
            }

            JoinLobby(lobbyInfo, SettingsManager.Instance.CurrentSettings.playerName, password);
        }
    }

    private VisualElement CreatePlayerItem(ScrollView scroll, ulong id, string name)
    {
        var item = new VisualElement();
        item.AddToClassList("player-item");

        var nameLabel = new Label(name);
        nameLabel.AddToClassList("player-name");

        var pingLabel = new Label($"{GetPing(id)} ms");
        pingLabel.AddToClassList("player-ping");

        var kickBtn = new Button(() => KickPlayer(id))
        {
            text = "Kick"
        };
        kickBtn.AddToClassList("kick-button");

        item.Add(nameLabel);
        item.Add(pingLabel);
        item.Add(kickBtn);

        scroll.Add(item);
        return item;
    }

    string GetPing(ulong id)
    {
        var serverWorld = GetServerWorld();
        if (serverWorld == null) return "0";
        var em = serverWorld.EntityManager;
        var query = em.CreateEntityQuery(ComponentType.ReadOnly<PlayerComponent>());
        using var players = query.ToComponentDataArray<PlayerComponent>(Unity.Collections.Allocator.Temp);
        foreach (var player in players)
        {
            if (player.ConnectionId == id)
                return player.Ping.ToString();
        }
        return "0";
    }

    private void OnLobbiesUpdated(List<LobbyInfo> lobbies)
    {
        UIManager.Instance.OnLobbyListUpdated();
    }

    private void ShutdownAllNetCodeWorlds()
    {
        // СОЗДАЕМ КОПИЮ СПИСКА МИРОВ ДЛЯ БЕЗОПАСНОЙ ИТЕРАЦИИ
        var worldsToDispose = new List<World>();
        foreach (var w in World.All)
        {
            if (w.IsCreated && (w.IsServer() || w.IsClient() || w.IsThinClient()))
                worldsToDispose.Add(w);
        }

        // ТЕПЕРЬ БЕЗОПАСНО УНИЧТОЖАЕМ МИРЫ
        foreach (var w in worldsToDispose)
        {
            try
            {
                w.Dispose();
            }
            catch (Exception e)
            {
                Debug.LogWarning($"Failed to dispose world {w.Name}: {e.Message}");
            }
        }
    }

    public bool IsConnectedToServer()
    {
        var clientWorld = GetClientWorld();
        if (clientWorld == null) return false;

        var query = clientWorld.EntityManager.CreateEntityQuery(typeof(NetworkStreamConnection));
        return !query.IsEmptyIgnoreFilter;
    }

    private void OnDestroy()
    {
        if (LobbyDiscovery.Instance != null)
        {
            LobbyDiscovery.Instance.OnLobbyClosed -= OnLobbyClosed;
        }
    }

}

Файл: ./Scripts/MenuFeature/Data/ECSLobbyData.cs
﻿// Assets/Scripts/ECSComponents.cs
using Unity.Entities;
using Unity.NetCode;
using Unity.Mathematics;
using Unity.Collections;
using Unity.Networking.Transport;
using System;

[GhostComponent(PrefabType = GhostPrefabType.All)]
public struct PlayerComponent : IComponentData
{
    [GhostField] public FixedString128Bytes Name;
    [GhostField] public ulong ConnectionId;
    [GhostField] public int Ping;
}

public struct KickPlayerCommand : IComponentData
{
    public ulong ConnectionId;
}

public struct LobbyDataComponent : IComponentData
{
    public FixedString128Bytes Name;
    public FixedString64Bytes Password;
    public int MaxPlayers;
    public bool IsOpen;
}

public struct LobbyPlayerBuffer : IBufferElementData
{
    public FixedString128Bytes PlayerName;
    public ulong ConnectionId;
}

/// <summary>
/// Информация о лобби, рассылаемая по LAN.
/// </summary>
[Serializable]
public struct LobbyInfo
{
    public string name;
    public int currentPlayers;
    public int maxPlayers;
    public bool isOpen;
    public string password;
    public string ip;
    public int port;
    public string uniqueId;

    public override string ToString()
    {
        return $"LobbyInfo: {name}, Players: {currentPlayers}/{maxPlayers}, Open: {isOpen}, IP: {ip}:{port}, ID: {uniqueId}";
    }
}

public struct LobbyData
{
    public string name;
    public string password;
    public int maxPlayers;
    public bool isOpen;
}

/// <summary>
/// RPC-команда от клиента: присоединение к лобби.
/// </summary>
public struct JoinLobbyCommand : IRpcCommand
{
    public FixedString128Bytes PlayerName;
    public FixedString64Bytes Weapon;
    public FixedString64Bytes Password;
}

public struct ConnectToServerCommand : IComponentData
{
    public FixedString128Bytes ServerIP;
    public ushort ServerPort;
    public FixedString128Bytes PlayerName;
    public FixedString64Bytes Password;
}

public struct NetworkStreamRequestConnect : IComponentData
{
    public NetworkEndpoint Endpoint;
}

public struct PlayerData
{
    public FixedString128Bytes name;
    public string selectedCharacter; // "Vacuum", "Toaster", "GPT"
}
Директория ./Scripts/UI не существует, пропускаем
Обработка директории: ./UI
==========================================

Файл: ./UI/MainMenuUI.uxml
<ui:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" noNamespaceSchemaLocation="../../UIElementsSchema/UIElements.xsd" editor-extension-mode="False">
    <Style src="project://database/Assets/UI/CommonStyles.uss?fileID=7433441132597879392&amp;guid=57b989746063a498cbd0477fa5efc62c&amp;type=3#CommonStyles" />
    <Style src="project://database/Assets/UI/MainMenuStyles.uss?fileID=7433441132597879392&amp;guid=c7f65d3fa004e444083d6493388b3fb6&amp;type=3#MainMenuStyles" />
    <ui:VisualElement name="root" class="root">
        <ui:VisualElement name="background" class="background" />
        <ui:VisualElement name="layout" class="layout">
            <ui:VisualElement name="menu_screen" class="screen" style="display: flex;">
                <ui:VisualElement class="logo" style="background-image: resource(&apos;logo&apos;);" />
                <ui:Button name="btnShowLobbyList" text="#create_lobby" class="menu-button" />
                <ui:Button name="btnStatistics" text="#statistics" class="menu-button" />
                <ui:Button name="btnQuit" text="#quit" class="menu-button" />
            </ui:VisualElement>
            <ui:VisualElement name="lobby_list_screen" class="screen hidden" style="display: none;">
                <ui:Label text="#network_game" name="title" class="network-title" />
                <ui:VisualElement name="panels_container" class="panels-container">
                    <ui:VisualElement name="left_panel" class="panel left-panel">
                        <ui:VisualElement class="panel-header">
                            <ui:Label text="#join_lobby" class="panel-header-text panel-header-text-left" />
                        </ui:VisualElement>
                        <ui:VisualElement class="panel-content">
                            <ui:VisualElement class="lobby-list-header">
                                <ui:Label text="#lobby_name" class="lobby-list-header-text lobby-list-header-text-1" style="width: 200px;" />
                                <ui:Label text="#player_count" class="lobby-list-header-text lobby-list-header-text-2" style="width: 80px; -unity-text-align: middle-center;" />
                                <ui:Label text="#type" class="lobby-list-header-text lobby-list-header-text-3" style="width: 120px; -unity-text-align: middle-center;" />
                                <ui:Label class="lobby-list-header-text lobby-list-header-text-4" />
                            </ui:VisualElement>
                            <ui:ScrollView name="lobbyListScroll" class="lobby-list-scroll" />
                        </ui:VisualElement>
                    </ui:VisualElement>
                    <ui:VisualElement name="right-panel" class="panel right-panel">
                        <ui:VisualElement class="panel-header">
                            <ui:Label text="#create_lobby" class="panel-header-text panel-header-text-right" />
                        </ui:VisualElement>
                        <ui:VisualElement class="panel-content">
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#lobby_name" class="section-label" />
                                <ui:VisualElement style="flex-grow: 1; flex-direction: row;">
                                    <ui:Button text="#random_lobby_name" name="randomNameBtn" class="random-button" />
                                    <ui:TextField name="playerNameField" placeholder-text="#enter_lobby_name" class="text-input transparent-bg" style="flex-grow: 1;" />
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#lobby_type" class="section-label" />
                                <ui:VisualElement class="radio-group">
                                    <ui:VisualElement class="radio-item">
                                        <ui:RadioButton name="radioOpen" text="#open" value="true" />
                                    </ui:VisualElement>
                                    <ui:VisualElement class="radio-item">
                                        <ui:RadioButton name="radioClosed" text="#closed" value="false" />
                                        <ui:VisualElement class="password-wrapper">
                                            <ui:TextField name="lobbyPassword" placeholder-text="#enter_password" class="password-input transparent-bg" value="" />
                                            <ui:Button name="togglePasswordVisibility" class="password-toggle-btn" style="background-image: url(&quot;project://database/Assets/UI%20Toolkit/UnityThemes/UnityDefaultRuntimeTheme.tss?fileID=8228938214290033325&amp;guid=293df427e8bd642319bd547283dd7192&amp;type=3#console.warnicon&quot;);" />
                                        </ui:VisualElement>
                                    </ui:VisualElement>
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#player_count" class="section-label" />
                                <ui:VisualElement class="slider-container">
                                    <ui:Label text="1" class="slider-label" />
                                    <ui:Slider name="playerCountSlider" low-value="1" high-value="9" value="5" class="slider" />
                                    <ui:Label text="9" class="slider-label" />
                                    <ui:Label name="playerCountValue" text="5" class="slider-value" />
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#difficulty" class="section-label" />
                                <ui:VisualElement class="character-grid">
                                    <ui:VisualElement name="charVacuum" class="character-card">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;robot-vacuum-cleaner&apos;);" />
                                        <ui:Label text="#robot_vacuum" class="character-name" />
                                    </ui:VisualElement>
                                    <ui:VisualElement name="charToaster" class="character-card selected">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;combat-toaster&apos;);" />
                                        <ui:Label text="#combat_toaster" class="character-name" />
                                    </ui:VisualElement>
                                    <ui:VisualElement name="charGPT" class="character-card">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;GPT-chat-coffee&apos;);" />
                                        <ui:Label text="#gpt_coffee" class="character-name" />
                                    </ui:VisualElement>
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#wave_count" class="section-label" />
                                <ui:VisualElement class="wave-slider-container">
                                    <ui:RadioButton name="waveCountRadio" text="#wave_count" value="true" />
                                    <ui:Label text="10" class="slider-label" />
                                    <ui:Slider name="waveCountSlider" low-value="10" high-value="50" value="10" class="slider" />
                                    <ui:Label text="50" class="slider-label" />
                                    <ui:Label name="waveCountValue" text="10" class="slider-value" />
                                    <ui:VisualElement class="infinity-checkbox">
                                        <ui:RadioButton name="infinityRadio" text="#infinity" value="false" />
                                    </ui:VisualElement>
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:Button name="btnRefreshLobbyList" text="#refresh_lobby_list" class="right-panel-button" />
                            <ui:Button name="btnCreateLobby" text="#create" class="right-panel-button" />
                        </ui:VisualElement>
                    </ui:VisualElement>
                </ui:VisualElement>
                <ui:VisualElement name="shortcuts_bar" class="shortcuts-bar">
                    <ui:VisualElement class="shortcut-item">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="Esc" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#close" class="shortcut-action" />
                    </ui:VisualElement>
                    <ui:VisualElement class="shortcut-item">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="Z" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#settings" class="shortcut-action" />
                    </ui:VisualElement>
                    <ui:VisualElement class="shortcut-item hidden">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="X" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#statistics" class="shortcut-action" />
                    </ui:VisualElement>
                </ui:VisualElement>
            </ui:VisualElement>
            <ui:VisualElement name="lobby_settings_screen" class="screen hidden" style="display: none;">
                <ui:Label text="#network_game" name="title" class="network-title" />
                <ui:VisualElement name="panels_container" class="panels-container">
                    <ui:VisualElement name="left_panel" class="panel left-panel">
                        <ui:VisualElement class="panel-header">
                            <ui:Label text="#players_header_label" class="panel-header-text panel-header-text-left" />
                        </ui:VisualElement>
                        <ui:VisualElement class="panel-content">
                            <ui:VisualElement class="lobby-list-header">
                                <ui:Label text="#player_name_label" class="lobby-list-header-text lobby-list-header-text-1" style="width: 200px;" />
                                <ui:Label text="#weapon_label" class="lobby-list-header-text lobby-list-header-text-2" style="width: 120px; -unity-text-align: middle-center;" />
                                <ui:Label text="#ping_label" class="lobby-list-header-text lobby-list-header-text-3" style="width: 80px; -unity-text-align: middle-center;" />
                                <ui:Label class="lobby-list-header-text lobby-list-header-text-4" />
                            </ui:VisualElement>
                            <ui:ScrollView name="playersScroll" class="lobby-list-scroll" />
                        </ui:VisualElement>
                    </ui:VisualElement>
                    <ui:VisualElement name="right-panel" class="panel right-panel">
                        <ui:VisualElement class="panel-header">
                            <ui:Label text="#lobby_settings_label" class="panel-header-text panel-header-text-right" />
                        </ui:VisualElement>
                        <ui:VisualElement class="panel-content" style="justify-content: flex-start;">
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#lobby_name_label" class="section-label" />
                                <ui:TextField name="lobbyNameField" value="" class="text-input transparent-bg" />
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#lobby_type_label" class="section-label" />
                                <ui:VisualElement class="radio-group">
                                    <ui:VisualElement class="radio-item">
                                        <ui:RadioButton name="radioOpen" text="#open" value="true" />
                                    </ui:VisualElement>
                                    <ui:VisualElement class="radio-item">
                                        <ui:RadioButton name="radioClosed" text="#closed" value="false" />
                                        <ui:VisualElement class="password-wrapper">
                                            <ui:TextField name="lobbyPasswordField" value="" class="password-input transparent-bg" />
                                            <ui:Button name="togglePasswordVisibility" class="password-toggle-btn" />
                                        </ui:VisualElement>
                                    </ui:VisualElement>
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#player_count_label" class="section-label" />
                                <ui:VisualElement class="slider-container">
                                    <ui:Label text="1" class="slider-label" />
                                    <ui:Slider name="playerCountSlider" low-value="1" high-value="9" value="3" class="slider" />
                                    <ui:Label text="9" class="slider-label" />
                                    <ui:Label name="playerCountValue" text="3" class="slider-value" />
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#difficulty_label" class="section-label" />
                                <ui:VisualElement class="character-grid">
                                    <ui:VisualElement name="charVacuum" class="character-card">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;robot-vacuum-cleaner&apos;);" />
                                        <ui:Label text="#robot_vacuum" class="character-name" />
                                    </ui:VisualElement>
                                    <ui:VisualElement name="charToaster" class="character-card selected">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;combat-toaster&apos;);" />
                                        <ui:Label text="#combat_toaster" class="character-name" />
                                    </ui:VisualElement>
                                    <ui:VisualElement name="charGPT" class="character-card">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;GPT-chat-coffee&apos;);" />
                                        <ui:Label text="#gpt_coffee" class="character-name" />
                                    </ui:VisualElement>
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#wave_count_label" class="section-label" />
                                <ui:VisualElement class="wave-slider-container">
                                    <ui:RadioButton name="waveCountRadio" text="#wave_count" value="true" />
                                    <ui:Label text="10" class="slider-label" />
                                    <ui:Slider name="waveCountSlider" low-value="10" high-value="50" value="30" class="slider" />
                                    <ui:Label text="50" class="slider-label" />
                                    <ui:Label name="waveCountValue" text="30" class="slider-value" />
                                    <ui:VisualElement class="infinity-checkbox">
                                        <ui:RadioButton name="infinityRadio" text="#infinity" value="false" />
                                    </ui:VisualElement>
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#start_game" class="section-label" />
                                <ui:Button name="btnStartGame" text="#start_game" class="right-panel-button start-game-btn" />
                            </ui:VisualElement>
                            <ui:Button name="btnDisbandLobby" text="#disband_lobby" class="right-panel-button disband-btn" />
                        </ui:VisualElement>
                    </ui:VisualElement>
                </ui:VisualElement>
                <ui:VisualElement name="shortcuts_bar" class="shortcuts-bar">
                    <ui:VisualElement class="shortcut-item">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="Esc" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#close" class="shortcut-action" />
                    </ui:VisualElement>
                    <ui:VisualElement class="shortcut-item">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="Z" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#settings" class="shortcut-action" />
                    </ui:VisualElement>
                    <ui:VisualElement class="shortcut-item">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="X" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#statistics" class="shortcut-action" />
                    </ui:VisualElement>
                </ui:VisualElement>
            </ui:VisualElement>
            <ui:VisualElement name="settings_screen" class="screen hidden" style="display: none;">
                <ui:Label text="#network_game" name="title" class="network-title" />
                <ui:VisualElement name="panels_container" class="panels-container">
                    <ui:VisualElement name="left_panel" class="panel left-panel">
                        <ui:VisualElement class="panel-header">
                            <ui:Label text="#join_lobby" class="panel-header-text panel-header-text-left" />
                        </ui:VisualElement>
                        <ui:VisualElement class="panel-content">
                            <ui:VisualElement class="lobby-list-header">
                                <ui:Label text="#lobby_name" class="lobby-list-header-text lobby-list-header-text-1" style="width: 200px;" />
                                <ui:Label text="#player_count" class="lobby-list-header-text lobby-list-header-text-2" style="width: 80px; -unity-text-align: middle-center;" />
                                <ui:Label text="#type" class="lobby-list-header-text lobby-list-header-text-3" style="width: 120px; -unity-text-align: middle-center;" />
                                <ui:Label class="lobby-list-header-text lobby-list-header-text-4" />
                            </ui:VisualElement>
                            <ui:ScrollView name="lobbyListScroll" class="lobby-list-scroll" />
                        </ui:VisualElement>
                    </ui:VisualElement>
                    <ui:VisualElement name="right-panel" class="panel right-panel">
                        <ui:VisualElement class="panel-header">
                            <ui:Label text="#create_lobby" class="panel-header-text panel-header-text-right" />
                        </ui:VisualElement>
                        <ui:VisualElement class="panel-content" style="justify-content: flex-start;">
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#current_player_name" class="section-label" />
                                <ui:VisualElement style="flex-grow: 1; flex-direction: row;">
                                    <ui:Button text="#random_name" name="RandomNameButton" class="random-button" />
                                    <ui:TextField name="createLobbyName" placeholder-text="#enter_name" class="text-input transparent-bg" style="flex-grow: 1;" />
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#default_arm" class="section-label" />
                                <ui:RadioButtonGroup>
                                    <ui:RadioButton label="#common_gun1" class="custom-radio-button" />
                                    <ui:RadioButton label="#common_gun2" class="custom-radio-button" />
                                    <ui:RadioButton label="#common_gun3" class="custom-radio-button" />
                                    <ui:RadioButton label="#common_gun4" class="custom-radio-button" />
                                </ui:RadioButtonGroup>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#music_volume" class="section-label" />
                                <ui:VisualElement class="slider-container">
                                    <ui:Label text="0" class="slider-label" />
                                    <ui:Slider name="musicSlider" low-value="0" high-value="100" value="5" class="slider" />
                                    <ui:Label text="100" class="slider-label" />
                                    <ui:Label name="musicVolumeLabel" text="5" class="slider-value" />
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#sound_volume" class="section-label" />
                                <ui:VisualElement class="slider-container">
                                    <ui:Label text="0" class="slider-label" />
                                    <ui:Slider name="soundVolumeSlider" low-value="0" high-value="100" value="5" class="slider" />
                                    <ui:Label text="100" class="slider-label" />
                                    <ui:Label name="soundVolumeLabel" text="5" class="slider-value" />
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#default_difficulty" class="section-label" />
                                <ui:VisualElement class="character-grid">
                                    <ui:VisualElement name="charVacuum" class="character-card">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;robot-vacuum-cleaner&apos;);" />
                                        <ui:Label text="#robot_vacuum" class="character-name" />
                                    </ui:VisualElement>
                                    <ui:VisualElement name="charToaster" class="character-card selected">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;combat-toaster&apos;);" />
                                        <ui:Label text="#combat_toaster" class="character-name" />
                                    </ui:VisualElement>
                                    <ui:VisualElement name="charGPT" class="character-card">
                                        <ui:VisualElement class="character-image" style="background-image: resource(&apos;GPT-chat-coffee&apos;);" />
                                        <ui:Label text="#gpt_coffee" class="character-name" />
                                    </ui:VisualElement>
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#screen_resolution" class="section-label" />
                                <ui:DropdownField name="resolutionDropdown" class="custom-dropfield" style="flex-grow: 1;" />
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#screen_quality" class="section-label" />
                                <ui:DropdownField name="qualityDropdown" class="custom-dropfield" style="flex-grow: 1;" />
                            </ui:VisualElement>
                            <ui:VisualElement class="form-section">
                                <ui:Label text="#language" class="section-label" />
                                <ui:VisualElement style="flex-grow: 1; flex-direction: row;">
                                    <ui:Button text="Русский" name="russianButton" class="random-button" />
                                    <ui:Button text="English" name="englishButton" class="random-button" />
                                </ui:VisualElement>
                            </ui:VisualElement>
                            <ui:VisualElement style="flex-grow: 1;">
                                <ui:Button text="#save_button" name="btnSave" class="random-button" />
                                <ui:Button text="#cancel_button" name="cancelBtn" class="random-button" />
                            </ui:VisualElement>
                        </ui:VisualElement>
                    </ui:VisualElement>
                </ui:VisualElement>
                <ui:VisualElement name="shortcuts_bar" class="shortcuts-bar">
                    <ui:VisualElement class="shortcut-item">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="Esc" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#close" class="shortcut-action" />
                    </ui:VisualElement>
                    <ui:VisualElement class="shortcut-item">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="Z" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#settings" class="shortcut-action" />
                    </ui:VisualElement>
                    <ui:VisualElement class="shortcut-item">
                        <ui:VisualElement class="shortcut-key">
                            <ui:Label text="X" class="shortcut-key-text" />
                        </ui:VisualElement>
                        <ui:Label text="#statistics" class="shortcut-action" />
                    </ui:VisualElement>
                </ui:VisualElement>
            </ui:VisualElement>
        </ui:VisualElement>
    </ui:VisualElement>
</ui:UXML>
Файл: ./UI/templates/PanelTemplateUI.uxml
<?xml version="1.0" encoding="utf-8"?>
<ui:UXML
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ui="UnityEngine.UIElements"
    xmlns:uie="UnityEditor.UIElements"
    xsi:noNamespaceSchemaLocation="../../../UIElementsSchema/UIElements.xsd"
>
    
</ui:UXML>
